{
    "docs": [
        {
            "location": "/", 
            "text": "LBRY JSON-RPC API Documentation\n\n\nblob_announce\n\n\nAnnounce blobs to the DHT\n\nArgs:\n    'blob_hash'    :  (str)  announce a blob, specified by blob_hash\n    'stream_hash'  :  (str)  announce all blobs associated with\n                             stream_hash\n    'sd_hash'      :  (str)  announce all blobs associated with\n                             sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblob_availability\n\n\nGet blob availability\n\nArgs:\n    'blob_hash'       :  (str)  check availability for this blob hash\n    'search_timeout'  :  (int)  how long to search for peers for the blob\n                                in the dht\n    'blob_timeout'    :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        \nis_available\n: \nbool, true if blob is available from a peer from peer list\n\n        \nreachable_peers\n: [\nip\n:\nport\n],\n        \nunreachable_peers\n: [\nip\n:\nport\n]\n    }\n\n\n\n\nblob_delete\n\n\nDelete a blob\n\nArgs:\n    'blob_hash'  :  (str)  blob hash of the blob to delete\n\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_get\n\n\nDownload and return a blob\n\nArgs:\n    'blob_hash' (required)  :  (str)  blob hash of the blob to get\n    'timeout'               :  (int)  timeout in number of seconds\n    'encoding'              :  (str)  by default no attempt at decoding\n                                      is made, can be set to one of the\n                                      following decoders:\n                                      'json'\n    'payment_rate_manager'  :  (str)  if not given the default payment rate\n                                      manager will be used.\n                                      supported alternative rate managers:\n                                      'only-free'\n\nReturns:\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nblob_list\n\n\nReturns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'needed'       :  (bool)  only return needed blobs\n    'finished'     :  (bool)  only return finished blobs\n    'uri'          :  (str)   filter blobs by stream in a uri\n    'stream_hash'  :  (str)   filter blobs by stream hash\n    'sd_hash'      :  (str)   filter blobs by sd hash\n    'page_size'    :  (int)   results page size\n    'page'         :  (int)   page of results to return\n\nReturns:\n    (list) List of blob hashes\n\n\n\n\nblob_reflect\n\n\nReflects specified blobs\n\nArgs:\n    'reflector_server'  :  (str)  reflector address\n\nReturns:\n    (list) reflected blob hashes\n\n\n\n\nblob_reflect_all\n\n\nReflects all saved blobs\n\nArgs:\n          None\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblock_show\n\n\nGet contents of a block\n\nArgs:\n    'blockhash' (required)  :  (str)  hash of the block to look up\n    'height' (required)     :  (int)  height of the block to look up\n\nReturns:\n    (dict) Requested block\n\n\n\n\nchannel_export\n\n\nExport serialized channel signing information for a given certificate claim id\n\nArgs:\n    'claim_id' (required)  :  (str)  Claim ID to export information about\n\nReturns:\n    (str) Serialized certificate information\n\n\n\n\nchannel_import\n\n\nImport serialized channel signing information (to allow signing new claims to the channel)\n\nArgs:\n    'serialized_certificate_info' (required)  :  (str)  certificate info\n\nReturns:\n    (dict) Result dictionary\n\n\n\n\nchannel_list\n\n\nGet certificate claim infos for channels that can be published to\n\nArgs:\n          None\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.\n\n\n\n\nchannel_new\n\n\nGenerate a publisher key and create a new '@' prefixed certificate claim\n\nArgs:\n    'channel_name' (required)  :  (str)    name of the channel prefixed with '@'\n    'amount' (required)        :  (float)  bid amount on the channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_abandon\n\n\nAbandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id'  :  (str)  claim_id of the claim to abandon\n    'txid'      :  (str)  txid of the claim to abandon\n    'nout'      :  (int)  nout of the claim to abandon\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_list\n\n\nList current claims and information about them for a given name\n\nArgs:\n    'name' (required)  :  (str)  name of the claim to list info about\n\nReturns:\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }\n\n\n\n\nclaim_list_by_channel\n\n\nGet paginated claims in a channel specified by a channel uri\n\nArgs:\n    'uri' (required)  :  (str)   uri of the channel\n    'uris'            :  (list)  uris of the channel\n    'page'            :  (int)   which page of results to return where page 1 is the first\n                                 page, defaults to no pages\n    'page_size'       :  (int)   number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }\n\n\n\n\nclaim_list_mine\n\n\nList my name claims\n\nArgs:\n          None\n\nReturns:\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \nclaim\n, \nupdate\n , or \nsupport\n\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]\n\n\n\n\nclaim_new_support\n\n\nSupport a name claim\n\nArgs:\n    'name' (required)      :  (str)    name of the claim to support\n    'claim_id' (required)  :  (str)    claim_id of the claim to support\n    'amount' (required)    :  (float)  amount of support\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_renew\n\n\nRenew claim(s) or support(s)\n\nArgs:\n    'outpoint' (required)  :  (str)  outpoint of the claim to renew\n    'height' (required)    :  (str)  update claims expiring before or at this block height\n\nReturns:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }\n\n\n\n\nclaim_send_to_address\n\n\nSend a name claim to an address\n\nArgs:\n    'claim_id' (required)  :  (str)  claim_id to send\n    'address' (required)   :  (str)  address to send the claim to\n    'amount'               :  (int)  Amount of credits to claim name for, defaults to the current amount\n                                     on the claim\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_show\n\n\nResolve claim info from txid/nout or with claim ID\n\nArgs:\n    'txid'      :  (str)  look for claim with this txid, nout must\n                          also be specified\n    'nout'      :  (int)  look for claim with this nout, txid must\n                          also be specified\n    'claim_id'  :  (str)  look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }\n\n\n\n\ncli_test_command\n\n\nThis command is only for testing the CLI argument parsing\nArgs:\n    'a_arg'               :  a    arg\n    'b_arg'               :  b    arg\n    'pos_arg' (required)  :  pos  arg\n    'pos_args'            :  pos  args\n    'pos_arg2'            :  pos  arg 2\n    'pos_arg3'            :  pos  arg 3\n\nReturns:\n    pos args\n\n\n\n\ncommands\n\n\nReturn a list of available commands\n\nArgs:\n          None\n\nReturns:\n    (list) list of available commands\n\n\n\n\ndaemon_stop\n\n\nStop lbrynet-daemon\n\nArgs:\n          None\n\nReturns:\n    (string) Shutdown message\n\n\n\n\nfile_delete\n\n\nDelete a LBRY file\n\nArgs:\n    'delete_from_download_dir'  :  (bool)  delete file from download directory,\n                                           instead of just deleting blobs\n    'delete_all'                :  (bool)  if there are multiple matching files,\n                                           allow the deletion of multiple files.\n                                           Otherwise do not delete anything.\n    'sd_hash'                   :  (str)   delete by file sd hash\n    'file_name'                 :  (str)   delete by file name in downloads folder\n    'stream_hash'               :  (str)   delete by file stream hash\n    'rowid'                     :  (int)   delete by file row id\n    'claim_id'                  :  (str)   delete by file claim id\n    'txid'                      :  (str)   delete by file claim txid\n    'nout'                      :  (int)   delete by file claim nout\n    'claim_name'                :  (str)   delete by file claim name\n    'channel_claim_id'          :  (str)   delete by file channel claim id\n    'channel_name'              :  (str)   delete by file channel claim name\n\nReturns:\n    (bool) true if deletion was successful\n\n\n\n\nfile_list\n\n\nList files limited by optional filters\n\nArgs:\n    'sd_hash'           :  (str)   get file with matching sd hash\n    'file_name'         :  (str)   get file with matching file name in the\n                                   downloads folder\n    'stream_hash'       :  (str)   get file with matching stream hash\n    'rowid'             :  (int)   get file with matching row id\n    'claim_id'          :  (str)   get file with matching claim id\n    'outpoint'          :  (str)   get file with matching claim outpoint\n    'txid'              :  (str)   get file with matching claim txid\n    'nout'              :  (int)   get file with matching claim nout\n    'channel_claim_id'  :  (str)   get file with matching channel claim id\n    'channel_name'      :  (str)   get file with matching channel name\n    'claim_name'        :  (str)   get file with matching claim name\n    'full_status'       :  (bool)  full status, populate the\n                                   'message' and 'size' fields\n    'sort'              :  (str)   sort by any property, like 'file_name'\n                                   or 'metadata.author'; to specify direction\n                                   append ',asc' or ',desc'\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) num_completed, None if full_status is false,\n            'blobs_in_stream': (int) None if full_status is false,\n            'status': (str) downloader status, None if full_status is false,\n            'claim_id': (str) None if full_status is false or if claim is not found,\n            'outpoint': (str) None if full_status is false or if claim is not found,\n            'txid': (str) None if full_status is false or if claim is not found,\n            'nout': (int) None if full_status is false or if claim is not found,\n            'metadata': (dict) None if full_status is false or if claim is not found,\n            'channel_claim_id': (str) None if full_status is false or if claim is not found or signed,\n            'channel_name': (str) None if full_status is false or if claim is not found or signed,\n            'claim_name': (str) None if full_status is false or if claim is not found\n        },\n    ]\n\n\n\n\nfile_reflect\n\n\nReflect all the blobs in a file matching the filter criteria\n\nArgs:\n    'sd_hash'      :  (str)  get file with matching sd hash\n    'file_name'    :  (str)  get file with matching file name in the\n                             downloads folder\n    'stream_hash'  :  (str)  get file with matching stream hash\n    'rowid'        :  (int)  get file with matching row id\n    'reflector'    :  (str)  reflector server, ip address or url\n                             by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected\n\n\n\n\nfile_set_status\n\n\nStart or stop downloading a file\n\nArgs:\n    'status' (required)  :  (str)  one of \nstart\n or \nstop\n\n    'sd_hash'            :  (str)  set status of file with matching sd hash\n    'file_name'          :  (str)  set status of file with matching file name in the\n                                   downloads folder\n    'stream_hash'        :  (str)  set status of file with matching stream hash\n    'rowid'              :  (int)  set status of file with matching row id\n\nReturns:\n    (str) Confirmation message\n\n\n\n\nget\n\n\nDownload stream from a LBRY name.\n\nArgs:\n    'uri'        :  (str)  uri of the content to download\n    'file_name'  :  (str)  specified name for the downloaded file\n    'timeout'    :  (int)  download timeout in number of seconds\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) num_completed, None if full_status is false,\n        'blobs_in_stream': (int) None if full_status is false,\n        'status': (str) downloader status, None if full_status is false,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }\n\n\n\n\nhelp\n\n\nReturn a useful message for an API command\n\nArgs:\n    'command'  :  (str)  command to retrieve documentation for\n\nReturns:\n    (str) Help message\n\n\n\n\npeer_list\n\n\nGet peers for blob hash\n\nArgs:\n    'blob_hash' (required)  :  (str)  find available peers for this blob hash\n    'timeout'               :  (int)  peer search timeout in seconds\n\nReturns:\n    (list) List of contact dictionaries {'host': \npeer ip\n, 'port': \npeer port\n, 'node_id': \npeer node id\n}\n\n\n\n\npeer_ping\n\n\nFind and ping a peer by node id\n\nArgs:\n          None\n\nReturns:\n    (str) pong, or {'error': \nerror message\n} if an error is encountered\n\n\n\n\npublish\n\n\nMake a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name' (required)  :  (str)      name of the content\n    'bid' (required)   :  (decimal)  amount to back the claim\n    'metadata'         :  (dict)     ClaimDict to associate with the claim.\n    'file_path'        :  (str)      path to file to be associated with name. If provided,\n                                     a lbry stream of this file will be used in 'sources'.\n                                     If no path is given but a sources dict is provided,\n                                     it will be used. If neither are provided, an\n                                     error is raised.\n    'fee'              :  (dict)     Dictionary representing key fee to download content:\n                                     {\n                                     'currency': currency_symbol,\n                                     'amount': decimal,\n                                     'address': str, optional\n                                     }\n                                     supported currencies: LBC, USD, BTC\n                                     If an address is not provided a new one will be\n                                     automatically generated. Default fee is zero.\n    'title'            :  (str)      title of the publication\n    'description'      :  (str)      description of the publication\n    'author'           :  (str)      author of the publication\n    'language'         :  (str)      language of the publication\n    'license'          :  (str)      publication license\n    'license_url'      :  (str)      publication license url\n    'thumbnail'        :  (str)      thumbnail url\n    'preview'          :  (str)      preview url\n    'nsfw'             :  (bool)     whether the content is nsfw\n    'sources'          :  (str)      {'lbry_sd_hash': sd_hash} specifies sd hash of file\n    'channel_name'     :  (str)      name of the publisher channel name in the wallet\n    'channel_id'       :  (str)      claim id of the publisher channel, does not check\n                                     for channel claim being in the wallet. This allows\n                                     publishing to a channel where only the certificate\n                                     private key is in the wallet.\n    'claim_address'    :  (str)      address where the claim is sent to, if not specified\n                                     new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nreport_bug\n\n\nReport a bug to slack\n\nArgs:\n    'message' (required)  :  (str)  Description of the bug\n\nReturns:\n    (bool) true if successful\n\n\n\n\nresolve\n\n\nResolve given LBRY URIs\n\nArgs:\n    'force'           :  (bool)  force refresh and ignore cache\n    'uri' (required)  :  (str)   uri to resolve\n    'uris'            :  (list)  uris to resolve\n\nReturns:\n    Dictionary of results, keyed by uri\n    '\nuri\n': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }\n\n\n\n\nresolve_name\n\n\nResolve stream info from a LBRY name\n\nArgs:\n    'name' (required)  :  (str)   the name to resolve\n    'force'            :  (bool)  force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable\n\n\n\n\nrouting_table_get\n\n\nGet DHT routing information\n\nArgs:\n          None\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n        \nbuckets\n: {\n            \nbucket index\n: [\n                {\n                    \naddress\n: (str) peer address,\n                    \nport\n: (int) peer udp port\n                    \nnode_id\n: (str) peer node id,\n                    \nblobs\n: (list) blob hashes announced by peer\n                }\n            ]\n        },\n        \ncontacts\n: (list) contact node ids,\n        \nblob_hashes\n: (list) all of the blob hashes stored by peers in the list of buckets,\n        \nnode_id\n: (str) the local dht node id\n    }\n\n\n\n\nsettings_get\n\n\nGet daemon settings\n\nArgs:\n          None\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings\n\n\n\n\nsettings_set\n\n\nSet daemon settings\n\nArgs:\n    'download_directory'             :  (str)    path of download directory\n    'data_rate'                      :  (float)  0.0001\n    'download_timeout'               :  (int)    180\n    'peer_port'                      :  (int)    3333\n    'max_key_fee'                    :  (dict)   maximum key fee for downloads,\n                                                 in the format:\n                                                 {\n                                                 'currency': \ncurrency_symbol\n,\n                                                 'amount': \namount\n\n                                                 }.\n                                                 In the CLI, it must be an escaped JSON string\n                                                 Supported currency symbols: LBC, USD, BTC\n    'disable_max_key_fee'            :  (bool)   False\n    'use_upnp'                       :  (bool)   True\n    'run_reflector_server'           :  (bool)   False\n    'cache_time'                     :  (int)    150\n    'reflect_uploads'                :  (bool)   True\n    'share_usage_data'               :  (bool)   True\n    'peer_search_timeout'            :  (int)    3\n    'sd_download_timeout'            :  (int)    3\n    'auto_renew_claim_height_delta'  :  (int)    0\n                                                 claims set to expire within this many blocks will be\n                                                 automatically renewed after startup (if set to 0, renews\n                                                 will not be made automatically)\n\nReturns:\n    (dict) Updated dictionary of daemon settings\n\n\n\n\nstatus\n\n\nGet daemon status\n\nArgs:\n    'session_status'  :  (bool)  include session status in results\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58,\n        'installation_id': installation id, base58,\n        'is_running': bool,\n        'is_first_run': bool,\n        'startup_status': {\n            'code': status code,\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code,\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n        'wallet_is_encrypted': bool,\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n    }\n\n\n\n\nstream_availability\n\n\nGet stream availability for lbry uri\n\nArgs:\n    'uri' (required)  :  (str)  check availability for this uri\n    'search_timeout'  :  (int)  how long to search for peers for the blob\n                                in the dht\n    'blob_timeout'    :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        'is_available': \nbool\n,\n        'did_decode': \nbool\n,\n        'did_resolve': \nbool\n,\n        'is_stream': \nbool\n,\n        'num_blobs_in_stream': \nint\n,\n        'sd_hash': \nstr\n,\n        'sd_blob_availability': \ndict\n see `blob_availability`,\n        'head_blob_hash': \nstr\n,\n        'head_blob_availability': \ndict\n see `blob_availability`,\n        'use_upnp': \nbool\n,\n        'upnp_redirect_is_set': \nbool\n,\n        'error': \nNone\n | \nstr\n error message\n    }\n\n\n\n\nstream_cost_estimate\n\n\nGet estimated cost for a lbry stream\n\nArgs:\n    'uri' (required)  :  (str)    uri to use\n    'size'            :  (float)  stream size in bytes. if provided an sd blob won't be\n                                  downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable\n\n\n\n\ntransaction_list\n\n\nList transactions belonging to wallet\n\nArgs:\n          None\n\nReturns:\n    (list) List of transactions\n\n    {\n        \nclaim_info\n: (list) claim info if in txn [{\n                                                \naddress\n: (str) address of claim,\n                                                \nbalance_delta\n: (float) bid amount,\n                                                \namount\n: (float) claim amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nabandon_info\n: (list) abandon info if in txn [{\n                                                \naddress\n: (str) address of abandoned claim,\n                                                \nbalance_delta\n: (float) returned amount,\n                                                \namount\n: (float) claim amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nconfirmations\n: (int) number of confirmations for the txn,\n        \ndate\n: (str) date and time of txn,\n        \nfee\n: (float) txn fee,\n        \nsupport_info\n: (list) support info if in txn [{\n                                                \naddress\n: (str) address of support,\n                                                \nbalance_delta\n: (float) support amount,\n                                                \namount\n: (float) support amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nis_tip\n: (bool),\n                                                \nnout\n: (int) nout\n                                                }],\n        \ntimestamp\n: (int) timestamp,\n        \ntxid\n: (str) txn id,\n        \nupdate_info\n: (list) update info if in txn [{\n                                                \naddress\n: (str) address of claim,\n                                                \nbalance_delta\n: (float) credited/debited\n                                                \namount\n: (float) absolute amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nvalue\n: (float) value of txn\n    }\n\n\n\n\ntransaction_show\n\n\nGet a decoded transaction from a txid\n\nArgs:\n    'txid' (required)  :  (str)  txid of the transaction\n\nReturns:\n    (dict) JSON formatted transaction\n\n\n\n\nutxo_list\n\n\nList unspent transaction outputs\n\nArgs:\n          None\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n            \naddress\n: (str) the output address\n            \namount\n: (float) unspent amount\n            \nheight\n: (int) block height\n            \nis_claim\n: (bool) is the tx a claim\n            \nis_coinbase\n: (bool) is the tx a coinbase tx\n            \nis_support\n: (bool) is the tx a support\n            \nis_update\n: (bool) is the tx an update\n            \nnout\n: (int) nout of the output\n            \ntxid\n: (str) txid of the output\n        },\n        ...\n    ]\n\n\n\n\nversion\n\n\nGet lbry version information\n\nArgs:\n          None\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \ndev\n, \nrc\n, \nrelease\n),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }\n\n\n\n\nwallet_balance\n\n\nReturn the balance of the wallet\n\nArgs:\n    'address'              :  (str)   If provided only the balance for this\n                                      address will be given\n    'include_unconfirmed'  :  (bool)  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet\n\n\n\n\nwallet_decrypt\n\n\nDecrypt an encrypted wallet, this will remove the wallet password\n\nArgs:\n          None\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false\n\n\n\n\nwallet_encrypt\n\n\nEncrypt a wallet with a password, if the wallet is already encrypted this will update\nthe password\n\nArgs:\n    'new_password' (required)  :  (str)  password string to be used for encrypting wallet\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false\n\n\n\n\nwallet_is_address_mine\n\n\nChecks if an address is associated with the current wallet.\n\nArgs:\n    'address' (required)  :  (str)  address to check\n\nReturns:\n    (bool) true, if address is associated with current wallet\n\n\n\n\nwallet_list\n\n\nList wallet addresses\n\nArgs:\n          None\n\nReturns:\n    List of wallet addresses\n\n\n\n\nwallet_new_address\n\n\nGenerate a new wallet address\n\nArgs:\n          None\n\nReturns:\n    (str) New wallet address in base58\n\n\n\n\nwallet_prefill_addresses\n\n\nCreate new addresses, each containing `amount` credits\n\nArgs:\n    'no_broadcast'              :  (bool)   whether to broadcast or not\n    'num_addresses' (required)  :  (int)    num of addresses to create\n    'amount' (required)         :  (float)  initial amount in each address\n\nReturns:\n    (dict) the resulting transaction\n\n\n\n\nwallet_public_key\n\n\nGet public key from wallet address\n\nArgs:\n    'address' (required)  :  (str)  address for which to get the public key\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.\n\n\n\n\nwallet_send\n\n\nSend credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nArgs:\n    'amount' (required)    :  (float)  amount of credit to send\n    'address' (required)   :  (str)    address to send credits to\n    'claim_id' (required)  :  (float)  claim_id of the claim to send to tip to\n\nReturns:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nwallet_unlock\n\n\nUnlock an encrypted wallet\n\nArgs:\n    'password' (required)  :  (str)  password for unlocking wallet\n\nReturns:\n    (bool) true if wallet is unlocked, otherwise false\n\n\n\n\nwallet_unused_address\n\n\nReturn an address containing no balance, will create\na new address if there is none.\n\nArgs:\n          None\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "API"
        }, 
        {
            "location": "/#lbry-json-rpc-api-documentation", 
            "text": "", 
            "title": "LBRY JSON-RPC API Documentation"
        }, 
        {
            "location": "/#blob_announce", 
            "text": "Announce blobs to the DHT\n\nArgs:\n    'blob_hash'    :  (str)  announce a blob, specified by blob_hash\n    'stream_hash'  :  (str)  announce all blobs associated with\n                             stream_hash\n    'sd_hash'      :  (str)  announce all blobs associated with\n                             sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_announce"
        }, 
        {
            "location": "/#blob_availability", 
            "text": "Get blob availability\n\nArgs:\n    'blob_hash'       :  (str)  check availability for this blob hash\n    'search_timeout'  :  (int)  how long to search for peers for the blob\n                                in the dht\n    'blob_timeout'    :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n         is_available :  bool, true if blob is available from a peer from peer list \n         reachable_peers : [ ip : port ],\n         unreachable_peers : [ ip : port ]\n    }", 
            "title": "blob_availability"
        }, 
        {
            "location": "/#blob_delete", 
            "text": "Delete a blob\n\nArgs:\n    'blob_hash'  :  (str)  blob hash of the blob to delete\n\nReturns:\n    (str) Success/fail message", 
            "title": "blob_delete"
        }, 
        {
            "location": "/#blob_get", 
            "text": "Download and return a blob\n\nArgs:\n    'blob_hash' (required)  :  (str)  blob hash of the blob to get\n    'timeout'               :  (int)  timeout in number of seconds\n    'encoding'              :  (str)  by default no attempt at decoding\n                                      is made, can be set to one of the\n                                      following decoders:\n                                      'json'\n    'payment_rate_manager'  :  (str)  if not given the default payment rate\n                                      manager will be used.\n                                      supported alternative rate managers:\n                                      'only-free'\n\nReturns:\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "blob_get"
        }, 
        {
            "location": "/#blob_list", 
            "text": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'needed'       :  (bool)  only return needed blobs\n    'finished'     :  (bool)  only return finished blobs\n    'uri'          :  (str)   filter blobs by stream in a uri\n    'stream_hash'  :  (str)   filter blobs by stream hash\n    'sd_hash'      :  (str)   filter blobs by sd hash\n    'page_size'    :  (int)   results page size\n    'page'         :  (int)   page of results to return\n\nReturns:\n    (list) List of blob hashes", 
            "title": "blob_list"
        }, 
        {
            "location": "/#blob_reflect", 
            "text": "Reflects specified blobs\n\nArgs:\n    'reflector_server'  :  (str)  reflector address\n\nReturns:\n    (list) reflected blob hashes", 
            "title": "blob_reflect"
        }, 
        {
            "location": "/#blob_reflect_all", 
            "text": "Reflects all saved blobs\n\nArgs:\n          None\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_reflect_all"
        }, 
        {
            "location": "/#block_show", 
            "text": "Get contents of a block\n\nArgs:\n    'blockhash' (required)  :  (str)  hash of the block to look up\n    'height' (required)     :  (int)  height of the block to look up\n\nReturns:\n    (dict) Requested block", 
            "title": "block_show"
        }, 
        {
            "location": "/#channel_export", 
            "text": "Export serialized channel signing information for a given certificate claim id\n\nArgs:\n    'claim_id' (required)  :  (str)  Claim ID to export information about\n\nReturns:\n    (str) Serialized certificate information", 
            "title": "channel_export"
        }, 
        {
            "location": "/#channel_import", 
            "text": "Import serialized channel signing information (to allow signing new claims to the channel)\n\nArgs:\n    'serialized_certificate_info' (required)  :  (str)  certificate info\n\nReturns:\n    (dict) Result dictionary", 
            "title": "channel_import"
        }, 
        {
            "location": "/#channel_list", 
            "text": "Get certificate claim infos for channels that can be published to\n\nArgs:\n          None\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.", 
            "title": "channel_list"
        }, 
        {
            "location": "/#channel_new", 
            "text": "Generate a publisher key and create a new '@' prefixed certificate claim\n\nArgs:\n    'channel_name' (required)  :  (str)    name of the channel prefixed with '@'\n    'amount' (required)        :  (float)  bid amount on the channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "channel_new"
        }, 
        {
            "location": "/#claim_abandon", 
            "text": "Abandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id'  :  (str)  claim_id of the claim to abandon\n    'txid'      :  (str)  txid of the claim to abandon\n    'nout'      :  (int)  nout of the claim to abandon\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_abandon"
        }, 
        {
            "location": "/#claim_list", 
            "text": "List current claims and information about them for a given name\n\nArgs:\n    'name' (required)  :  (str)  name of the claim to list info about\n\nReturns:\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }", 
            "title": "claim_list"
        }, 
        {
            "location": "/#claim_list_by_channel", 
            "text": "Get paginated claims in a channel specified by a channel uri\n\nArgs:\n    'uri' (required)  :  (str)   uri of the channel\n    'uris'            :  (list)  uris of the channel\n    'page'            :  (int)   which page of results to return where page 1 is the first\n                                 page, defaults to no pages\n    'page_size'       :  (int)   number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }", 
            "title": "claim_list_by_channel"
        }, 
        {
            "location": "/#claim_list_mine", 
            "text": "List my name claims\n\nArgs:\n          None\n\nReturns:\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str)  claim ,  update  , or  support \n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]", 
            "title": "claim_list_mine"
        }, 
        {
            "location": "/#claim_new_support", 
            "text": "Support a name claim\n\nArgs:\n    'name' (required)      :  (str)    name of the claim to support\n    'claim_id' (required)  :  (str)    claim_id of the claim to support\n    'amount' (required)    :  (float)  amount of support\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_new_support"
        }, 
        {
            "location": "/#claim_renew", 
            "text": "Renew claim(s) or support(s)\n\nArgs:\n    'outpoint' (required)  :  (str)  outpoint of the claim to renew\n    'height' (required)    :  (str)  update claims expiring before or at this block height\n\nReturns:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }", 
            "title": "claim_renew"
        }, 
        {
            "location": "/#claim_send_to_address", 
            "text": "Send a name claim to an address\n\nArgs:\n    'claim_id' (required)  :  (str)  claim_id to send\n    'address' (required)   :  (str)  address to send the claim to\n    'amount'               :  (int)  Amount of credits to claim name for, defaults to the current amount\n                                     on the claim\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "claim_send_to_address"
        }, 
        {
            "location": "/#claim_show", 
            "text": "Resolve claim info from txid/nout or with claim ID\n\nArgs:\n    'txid'      :  (str)  look for claim with this txid, nout must\n                          also be specified\n    'nout'      :  (int)  look for claim with this nout, txid must\n                          also be specified\n    'claim_id'  :  (str)  look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }", 
            "title": "claim_show"
        }, 
        {
            "location": "/#cli_test_command", 
            "text": "This command is only for testing the CLI argument parsing\nArgs:\n    'a_arg'               :  a    arg\n    'b_arg'               :  b    arg\n    'pos_arg' (required)  :  pos  arg\n    'pos_args'            :  pos  args\n    'pos_arg2'            :  pos  arg 2\n    'pos_arg3'            :  pos  arg 3\n\nReturns:\n    pos args", 
            "title": "cli_test_command"
        }, 
        {
            "location": "/#commands", 
            "text": "Return a list of available commands\n\nArgs:\n          None\n\nReturns:\n    (list) list of available commands", 
            "title": "commands"
        }, 
        {
            "location": "/#daemon_stop", 
            "text": "Stop lbrynet-daemon\n\nArgs:\n          None\n\nReturns:\n    (string) Shutdown message", 
            "title": "daemon_stop"
        }, 
        {
            "location": "/#file_delete", 
            "text": "Delete a LBRY file\n\nArgs:\n    'delete_from_download_dir'  :  (bool)  delete file from download directory,\n                                           instead of just deleting blobs\n    'delete_all'                :  (bool)  if there are multiple matching files,\n                                           allow the deletion of multiple files.\n                                           Otherwise do not delete anything.\n    'sd_hash'                   :  (str)   delete by file sd hash\n    'file_name'                 :  (str)   delete by file name in downloads folder\n    'stream_hash'               :  (str)   delete by file stream hash\n    'rowid'                     :  (int)   delete by file row id\n    'claim_id'                  :  (str)   delete by file claim id\n    'txid'                      :  (str)   delete by file claim txid\n    'nout'                      :  (int)   delete by file claim nout\n    'claim_name'                :  (str)   delete by file claim name\n    'channel_claim_id'          :  (str)   delete by file channel claim id\n    'channel_name'              :  (str)   delete by file channel claim name\n\nReturns:\n    (bool) true if deletion was successful", 
            "title": "file_delete"
        }, 
        {
            "location": "/#file_list", 
            "text": "List files limited by optional filters\n\nArgs:\n    'sd_hash'           :  (str)   get file with matching sd hash\n    'file_name'         :  (str)   get file with matching file name in the\n                                   downloads folder\n    'stream_hash'       :  (str)   get file with matching stream hash\n    'rowid'             :  (int)   get file with matching row id\n    'claim_id'          :  (str)   get file with matching claim id\n    'outpoint'          :  (str)   get file with matching claim outpoint\n    'txid'              :  (str)   get file with matching claim txid\n    'nout'              :  (int)   get file with matching claim nout\n    'channel_claim_id'  :  (str)   get file with matching channel claim id\n    'channel_name'      :  (str)   get file with matching channel name\n    'claim_name'        :  (str)   get file with matching claim name\n    'full_status'       :  (bool)  full status, populate the\n                                   'message' and 'size' fields\n    'sort'              :  (str)   sort by any property, like 'file_name'\n                                   or 'metadata.author'; to specify direction\n                                   append ',asc' or ',desc'\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) num_completed, None if full_status is false,\n            'blobs_in_stream': (int) None if full_status is false,\n            'status': (str) downloader status, None if full_status is false,\n            'claim_id': (str) None if full_status is false or if claim is not found,\n            'outpoint': (str) None if full_status is false or if claim is not found,\n            'txid': (str) None if full_status is false or if claim is not found,\n            'nout': (int) None if full_status is false or if claim is not found,\n            'metadata': (dict) None if full_status is false or if claim is not found,\n            'channel_claim_id': (str) None if full_status is false or if claim is not found or signed,\n            'channel_name': (str) None if full_status is false or if claim is not found or signed,\n            'claim_name': (str) None if full_status is false or if claim is not found\n        },\n    ]", 
            "title": "file_list"
        }, 
        {
            "location": "/#file_reflect", 
            "text": "Reflect all the blobs in a file matching the filter criteria\n\nArgs:\n    'sd_hash'      :  (str)  get file with matching sd hash\n    'file_name'    :  (str)  get file with matching file name in the\n                             downloads folder\n    'stream_hash'  :  (str)  get file with matching stream hash\n    'rowid'        :  (int)  get file with matching row id\n    'reflector'    :  (str)  reflector server, ip address or url\n                             by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected", 
            "title": "file_reflect"
        }, 
        {
            "location": "/#file_set_status", 
            "text": "Start or stop downloading a file\n\nArgs:\n    'status' (required)  :  (str)  one of  start  or  stop \n    'sd_hash'            :  (str)  set status of file with matching sd hash\n    'file_name'          :  (str)  set status of file with matching file name in the\n                                   downloads folder\n    'stream_hash'        :  (str)  set status of file with matching stream hash\n    'rowid'              :  (int)  set status of file with matching row id\n\nReturns:\n    (str) Confirmation message", 
            "title": "file_set_status"
        }, 
        {
            "location": "/#get", 
            "text": "Download stream from a LBRY name.\n\nArgs:\n    'uri'        :  (str)  uri of the content to download\n    'file_name'  :  (str)  specified name for the downloaded file\n    'timeout'    :  (int)  download timeout in number of seconds\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) num_completed, None if full_status is false,\n        'blobs_in_stream': (int) None if full_status is false,\n        'status': (str) downloader status, None if full_status is false,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }", 
            "title": "get"
        }, 
        {
            "location": "/#help", 
            "text": "Return a useful message for an API command\n\nArgs:\n    'command'  :  (str)  command to retrieve documentation for\n\nReturns:\n    (str) Help message", 
            "title": "help"
        }, 
        {
            "location": "/#peer_list", 
            "text": "Get peers for blob hash\n\nArgs:\n    'blob_hash' (required)  :  (str)  find available peers for this blob hash\n    'timeout'               :  (int)  peer search timeout in seconds\n\nReturns:\n    (list) List of contact dictionaries {'host':  peer ip , 'port':  peer port , 'node_id':  peer node id }", 
            "title": "peer_list"
        }, 
        {
            "location": "/#peer_ping", 
            "text": "Find and ping a peer by node id\n\nArgs:\n          None\n\nReturns:\n    (str) pong, or {'error':  error message } if an error is encountered", 
            "title": "peer_ping"
        }, 
        {
            "location": "/#publish", 
            "text": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name' (required)  :  (str)      name of the content\n    'bid' (required)   :  (decimal)  amount to back the claim\n    'metadata'         :  (dict)     ClaimDict to associate with the claim.\n    'file_path'        :  (str)      path to file to be associated with name. If provided,\n                                     a lbry stream of this file will be used in 'sources'.\n                                     If no path is given but a sources dict is provided,\n                                     it will be used. If neither are provided, an\n                                     error is raised.\n    'fee'              :  (dict)     Dictionary representing key fee to download content:\n                                     {\n                                     'currency': currency_symbol,\n                                     'amount': decimal,\n                                     'address': str, optional\n                                     }\n                                     supported currencies: LBC, USD, BTC\n                                     If an address is not provided a new one will be\n                                     automatically generated. Default fee is zero.\n    'title'            :  (str)      title of the publication\n    'description'      :  (str)      description of the publication\n    'author'           :  (str)      author of the publication\n    'language'         :  (str)      language of the publication\n    'license'          :  (str)      publication license\n    'license_url'      :  (str)      publication license url\n    'thumbnail'        :  (str)      thumbnail url\n    'preview'          :  (str)      preview url\n    'nsfw'             :  (bool)     whether the content is nsfw\n    'sources'          :  (str)      {'lbry_sd_hash': sd_hash} specifies sd hash of file\n    'channel_name'     :  (str)      name of the publisher channel name in the wallet\n    'channel_id'       :  (str)      claim id of the publisher channel, does not check\n                                     for channel claim being in the wallet. This allows\n                                     publishing to a channel where only the certificate\n                                     private key is in the wallet.\n    'claim_address'    :  (str)      address where the claim is sent to, if not specified\n                                     new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "publish"
        }, 
        {
            "location": "/#report_bug", 
            "text": "Report a bug to slack\n\nArgs:\n    'message' (required)  :  (str)  Description of the bug\n\nReturns:\n    (bool) true if successful", 
            "title": "report_bug"
        }, 
        {
            "location": "/#resolve", 
            "text": "Resolve given LBRY URIs\n\nArgs:\n    'force'           :  (bool)  force refresh and ignore cache\n    'uri' (required)  :  (str)   uri to resolve\n    'uris'            :  (list)  uris to resolve\n\nReturns:\n    Dictionary of results, keyed by uri\n    ' uri ': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }", 
            "title": "resolve"
        }, 
        {
            "location": "/#resolve_name", 
            "text": "Resolve stream info from a LBRY name\n\nArgs:\n    'name' (required)  :  (str)   the name to resolve\n    'force'            :  (bool)  force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable", 
            "title": "resolve_name"
        }, 
        {
            "location": "/#routing_table_get", 
            "text": "Get DHT routing information\n\nArgs:\n          None\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n         buckets : {\n             bucket index : [\n                {\n                     address : (str) peer address,\n                     port : (int) peer udp port\n                     node_id : (str) peer node id,\n                     blobs : (list) blob hashes announced by peer\n                }\n            ]\n        },\n         contacts : (list) contact node ids,\n         blob_hashes : (list) all of the blob hashes stored by peers in the list of buckets,\n         node_id : (str) the local dht node id\n    }", 
            "title": "routing_table_get"
        }, 
        {
            "location": "/#settings_get", 
            "text": "Get daemon settings\n\nArgs:\n          None\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings", 
            "title": "settings_get"
        }, 
        {
            "location": "/#settings_set", 
            "text": "Set daemon settings\n\nArgs:\n    'download_directory'             :  (str)    path of download directory\n    'data_rate'                      :  (float)  0.0001\n    'download_timeout'               :  (int)    180\n    'peer_port'                      :  (int)    3333\n    'max_key_fee'                    :  (dict)   maximum key fee for downloads,\n                                                 in the format:\n                                                 {\n                                                 'currency':  currency_symbol ,\n                                                 'amount':  amount \n                                                 }.\n                                                 In the CLI, it must be an escaped JSON string\n                                                 Supported currency symbols: LBC, USD, BTC\n    'disable_max_key_fee'            :  (bool)   False\n    'use_upnp'                       :  (bool)   True\n    'run_reflector_server'           :  (bool)   False\n    'cache_time'                     :  (int)    150\n    'reflect_uploads'                :  (bool)   True\n    'share_usage_data'               :  (bool)   True\n    'peer_search_timeout'            :  (int)    3\n    'sd_download_timeout'            :  (int)    3\n    'auto_renew_claim_height_delta'  :  (int)    0\n                                                 claims set to expire within this many blocks will be\n                                                 automatically renewed after startup (if set to 0, renews\n                                                 will not be made automatically)\n\nReturns:\n    (dict) Updated dictionary of daemon settings", 
            "title": "settings_set"
        }, 
        {
            "location": "/#status", 
            "text": "Get daemon status\n\nArgs:\n    'session_status'  :  (bool)  include session status in results\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58,\n        'installation_id': installation id, base58,\n        'is_running': bool,\n        'is_first_run': bool,\n        'startup_status': {\n            'code': status code,\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code,\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n        'wallet_is_encrypted': bool,\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n    }", 
            "title": "status"
        }, 
        {
            "location": "/#stream_availability", 
            "text": "Get stream availability for lbry uri\n\nArgs:\n    'uri' (required)  :  (str)  check availability for this uri\n    'search_timeout'  :  (int)  how long to search for peers for the blob\n                                in the dht\n    'blob_timeout'    :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        'is_available':  bool ,\n        'did_decode':  bool ,\n        'did_resolve':  bool ,\n        'is_stream':  bool ,\n        'num_blobs_in_stream':  int ,\n        'sd_hash':  str ,\n        'sd_blob_availability':  dict  see `blob_availability`,\n        'head_blob_hash':  str ,\n        'head_blob_availability':  dict  see `blob_availability`,\n        'use_upnp':  bool ,\n        'upnp_redirect_is_set':  bool ,\n        'error':  None  |  str  error message\n    }", 
            "title": "stream_availability"
        }, 
        {
            "location": "/#stream_cost_estimate", 
            "text": "Get estimated cost for a lbry stream\n\nArgs:\n    'uri' (required)  :  (str)    uri to use\n    'size'            :  (float)  stream size in bytes. if provided an sd blob won't be\n                                  downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable", 
            "title": "stream_cost_estimate"
        }, 
        {
            "location": "/#transaction_list", 
            "text": "List transactions belonging to wallet\n\nArgs:\n          None\n\nReturns:\n    (list) List of transactions\n\n    {\n         claim_info : (list) claim info if in txn [{\n                                                 address : (str) address of claim,\n                                                 balance_delta : (float) bid amount,\n                                                 amount : (float) claim amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         abandon_info : (list) abandon info if in txn [{\n                                                 address : (str) address of abandoned claim,\n                                                 balance_delta : (float) returned amount,\n                                                 amount : (float) claim amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         confirmations : (int) number of confirmations for the txn,\n         date : (str) date and time of txn,\n         fee : (float) txn fee,\n         support_info : (list) support info if in txn [{\n                                                 address : (str) address of support,\n                                                 balance_delta : (float) support amount,\n                                                 amount : (float) support amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 is_tip : (bool),\n                                                 nout : (int) nout\n                                                }],\n         timestamp : (int) timestamp,\n         txid : (str) txn id,\n         update_info : (list) update info if in txn [{\n                                                 address : (str) address of claim,\n                                                 balance_delta : (float) credited/debited\n                                                 amount : (float) absolute amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         value : (float) value of txn\n    }", 
            "title": "transaction_list"
        }, 
        {
            "location": "/#transaction_show", 
            "text": "Get a decoded transaction from a txid\n\nArgs:\n    'txid' (required)  :  (str)  txid of the transaction\n\nReturns:\n    (dict) JSON formatted transaction", 
            "title": "transaction_show"
        }, 
        {
            "location": "/#utxo_list", 
            "text": "List unspent transaction outputs\n\nArgs:\n          None\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n             address : (str) the output address\n             amount : (float) unspent amount\n             height : (int) block height\n             is_claim : (bool) is the tx a claim\n             is_coinbase : (bool) is the tx a coinbase tx\n             is_support : (bool) is the tx a support\n             is_update : (bool) is the tx an update\n             nout : (int) nout of the output\n             txid : (str) txid of the output\n        },\n        ...\n    ]", 
            "title": "utxo_list"
        }, 
        {
            "location": "/#version", 
            "text": "Get lbry version information\n\nArgs:\n          None\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g.  dev ,  rc ,  release ),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }", 
            "title": "version"
        }, 
        {
            "location": "/#wallet_balance", 
            "text": "Return the balance of the wallet\n\nArgs:\n    'address'              :  (str)   If provided only the balance for this\n                                      address will be given\n    'include_unconfirmed'  :  (bool)  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet", 
            "title": "wallet_balance"
        }, 
        {
            "location": "/#wallet_decrypt", 
            "text": "Decrypt an encrypted wallet, this will remove the wallet password\n\nArgs:\n          None\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false", 
            "title": "wallet_decrypt"
        }, 
        {
            "location": "/#wallet_encrypt", 
            "text": "Encrypt a wallet with a password, if the wallet is already encrypted this will update\nthe password\n\nArgs:\n    'new_password' (required)  :  (str)  password string to be used for encrypting wallet\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false", 
            "title": "wallet_encrypt"
        }, 
        {
            "location": "/#wallet_is_address_mine", 
            "text": "Checks if an address is associated with the current wallet.\n\nArgs:\n    'address' (required)  :  (str)  address to check\n\nReturns:\n    (bool) true, if address is associated with current wallet", 
            "title": "wallet_is_address_mine"
        }, 
        {
            "location": "/#wallet_list", 
            "text": "List wallet addresses\n\nArgs:\n          None\n\nReturns:\n    List of wallet addresses", 
            "title": "wallet_list"
        }, 
        {
            "location": "/#wallet_new_address", 
            "text": "Generate a new wallet address\n\nArgs:\n          None\n\nReturns:\n    (str) New wallet address in base58", 
            "title": "wallet_new_address"
        }, 
        {
            "location": "/#wallet_prefill_addresses", 
            "text": "Create new addresses, each containing `amount` credits\n\nArgs:\n    'no_broadcast'              :  (bool)   whether to broadcast or not\n    'num_addresses' (required)  :  (int)    num of addresses to create\n    'amount' (required)         :  (float)  initial amount in each address\n\nReturns:\n    (dict) the resulting transaction", 
            "title": "wallet_prefill_addresses"
        }, 
        {
            "location": "/#wallet_public_key", 
            "text": "Get public key from wallet address\n\nArgs:\n    'address' (required)  :  (str)  address for which to get the public key\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.", 
            "title": "wallet_public_key"
        }, 
        {
            "location": "/#wallet_send", 
            "text": "Send credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nArgs:\n    'amount' (required)    :  (float)  amount of credit to send\n    'address' (required)   :  (str)    address to send credits to\n    'claim_id' (required)  :  (float)  claim_id of the claim to send to tip to\n\nReturns:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "wallet_send"
        }, 
        {
            "location": "/#wallet_unlock", 
            "text": "Unlock an encrypted wallet\n\nArgs:\n    'password' (required)  :  (str)  password for unlocking wallet\n\nReturns:\n    (bool) true if wallet is unlocked, otherwise false", 
            "title": "wallet_unlock"
        }, 
        {
            "location": "/#wallet_unused_address", 
            "text": "Return an address containing no balance, will create\na new address if there is none.\n\nArgs:\n          None\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "wallet_unused_address"
        }, 
        {
            "location": "/cli/", 
            "text": "LBRY JSON-RPC API Documentation\n\n\nblob_announce\n\n\nAnnounce blobs to the DHT\n\nUsage:\n    blob_announce [\nblob_hash\n | --blob_hash=\nblob_hash\n]\n                  [\nstream_hash\n | --stream_hash=\nstream_hash\n] | [\nsd_hash\n | --sd_hash=\nsd_hash\n]\n\n\nOptions:\n    --blob_hash=\nblob_hash\n      :  (str)  announce a blob, specified by blob_hash\n    --stream_hash=\nstream_hash\n  :  (str)  announce all blobs associated with\n                                           stream_hash\n    --sd_hash=\nsd_hash\n          :  (str)  announce all blobs associated with\n                                           sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblob_availability\n\n\nGet blob availability\n\nUsage:\n    blob_availability (\nblob_hash\n) [\nsearch_timeout\n | --search_timeout=\nsearch_timeout\n]\n                      [\nblob_timeout\n | --blob_timeout=\nblob_timeout\n]\n\n\nOptions:\n    --blob_hash=\nblob_hash\n            :  (str)  check availability for this blob hash\n    --search_timeout=\nsearch_timeout\n  :  (int)  how long to search for peers for the blob\n                                                 in the dht\n    --blob_timeout=\nblob_timeout\n      :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        \nis_available\n: \nbool, true if blob is available from a peer from peer list\n\n        \nreachable_peers\n: [\nip\n:\nport\n],\n        \nunreachable_peers\n: [\nip\n:\nport\n]\n    }\n\n\n\n\nblob_delete\n\n\nDelete a blob\n\nUsage:\n    blob_delete (\nblob_hash\n | --blob_hash=\nblob_hash)\n\n\nOptions:\n    --blob_hash=\nblob_hash\n  :  (str)  blob hash of the blob to delete\n\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_get\n\n\nDownload and return a blob\n\nUsage:\n    blob_get (\nblob_hash\n | --blob_hash=\nblob_hash\n) [--timeout=\ntimeout\n]\n             [--encoding=\nencoding\n] [--payment_rate_manager=\npayment_rate_manager\n]\n\n\nOptions:\n    --blob_hash=\nblob_hash\n                        :  (str)  blob hash of the blob to get\n    --timeout=\ntimeout\n                            :  (int)  timeout in number of seconds\n    --encoding=\nencoding\n                          :  (str)  by default no attempt at decoding\n                                                             is made, can be set to one of the\n                                                             following decoders:\n                                                             'json'\n    --payment_rate_manager=\npayment_rate_manager\n  :  (str)  if not given the default payment rate\n                                                             manager will be used.\n                                                             supported alternative rate managers:\n                                                             'only-free'\n\nReturns:\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nblob_list\n\n\nReturns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nUsage:\n    blob_list [--needed] [--finished] [\nuri\n | --uri=\nuri\n]\n              [\nstream_hash\n | --stream_hash=\nstream_hash\n]\n              [\nsd_hash\n | --sd_hash=\nsd_hash\n]\n              [\npage_size\n | --page_size=\npage_size\n]\n              [\npage\n | --page=\npage\n]\n\n\nOptions:\n    --needed                     :  (bool)  only return needed blobs\n    --finished                   :  (bool)  only return finished blobs\n    --uri=\nuri\n                  :  (str)   filter blobs by stream in a uri\n    --stream_hash=\nstream_hash\n  :  (str)   filter blobs by stream hash\n    --sd_hash=\nsd_hash\n          :  (str)   filter blobs by sd hash\n    --page_size=\npage_size\n      :  (int)   results page size\n    --page=\npage\n                :  (int)   page of results to return\n\nReturns:\n    (list) List of blob hashes\n\n\n\n\nblob_reflect\n\n\nReflects specified blobs\n\nUsage:\n    blob_reflect (\nblob_hashes\n...) [--reflector_server=\nreflector_server\n]\n\n\nOptions:\n    --reflector_server=\nreflector_server\n  :  (str)  reflector address\n\nReturns:\n    (list) reflected blob hashes\n\n\n\n\nblob_reflect_all\n\n\nReflects all saved blobs\n\nUsage:\n    blob_reflect_all\n\n\nOptions:\n          None\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblock_show\n\n\nGet contents of a block\n\nUsage:\n    block_show (\nblockhash\n | --blockhash=\nblockhash\n) | (\nheight\n | --height=\nheight\n)\n\n\nOptions:\n    --blockhash=\nblockhash\n  :  (str)  hash of the block to look up\n    --height=\nheight\n        :  (int)  height of the block to look up\n\nReturns:\n    (dict) Requested block\n\n\n\n\nchannel_export\n\n\nExport serialized channel signing information for a given certificate claim id\n\nUsage:\n    channel_export (\nclaim_id\n | --claim_id=\nclaim_id\n)\n\n\nOptions:\n    --claim_id=\nclaim_id\n  :  (str)  Claim ID to export information about\n\nReturns:\n    (str) Serialized certificate information\n\n\n\n\nchannel_import\n\n\nImport serialized channel signing information (to allow signing new claims to the channel)\n\nUsage:\n    channel_import (\nserialized_certificate_info\n | --serialized_certificate_info=\nserialized_certificate_info\n)\n\n\nOptions:\n    --serialized_certificate_info=\nserialized_certificate_info\n  :  (str)  certificate info\n\nReturns:\n    (dict) Result dictionary\n\n\n\n\nchannel_list\n\n\nGet certificate claim infos for channels that can be published to\n\nUsage:\n    channel_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.\n\n\n\n\nchannel_new\n\n\nGenerate a publisher key and create a new '@' prefixed certificate claim\n\nUsage:\n    channel_new (\nchannel_name\n | --channel_name=\nchannel_name\n)\n                (\namount\n | --amount=\namount\n)\n\n\nOptions:\n    --channel_name=\nchannel_name\n  :  (str)    name of the channel prefixed with '@'\n    --amount=\namount\n              :  (float)  bid amount on the channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_abandon\n\n\nAbandon a name and reclaim credits from the claim\n\nUsage:\n    claim_abandon [\nclaim_id\n | --claim_id=\nclaim_id\n]\n                  [\ntxid\n | --txid=\ntxid\n] [\nnout\n | --nout=\nnout\n]\n\n\nOptions:\n    --claim_id=\nclaim_id\n  :  (str)  claim_id of the claim to abandon\n    --txid=\ntxid\n          :  (str)  txid of the claim to abandon\n    --nout=\nnout\n          :  (int)  nout of the claim to abandon\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_list\n\n\nList current claims and information about them for a given name\n\nUsage:\n    claim_list (\nname\n | --name=\nname\n)\n\n\nOptions:\n    --name=\nname\n  :  (str)  name of the claim to list info about\n\nReturns:\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }\n\n\n\n\nclaim_list_by_channel\n\n\nGet paginated claims in a channel specified by a channel uri\n\nUsage:\n    claim_list_by_channel (\nuri\n | --uri=\nuri\n) [\nuris\n...] [--page=\npage\n]\n                           [--page_size=\npage_size\n]\n\n\nOptions:\n    --uri=\nuri\n              :  (str)   uri of the channel\n    --uris=\nuris\n            :  (list)  uris of the channel\n    --page=\npage\n            :  (int)   which page of results to return where page 1 is the first\n                                        page, defaults to no pages\n    --page_size=\npage_size\n  :  (int)   number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }\n\n\n\n\nclaim_list_mine\n\n\nList my name claims\n\nUsage:\n    claim_list_mine\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \nclaim\n, \nupdate\n , or \nsupport\n\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]\n\n\n\n\nclaim_new_support\n\n\nSupport a name claim\n\nUsage:\n    claim_new_support (\nname\n | --name=\nname\n) (\nclaim_id\n | --claim_id=\nclaim_id\n)\n                      (\namount\n | --amount=\namount\n)\n\n\nOptions:\n    --name=\nname\n          :  (str)    name of the claim to support\n    --claim_id=\nclaim_id\n  :  (str)    claim_id of the claim to support\n    --amount=\namount\n      :  (float)  amount of support\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_renew\n\n\nRenew claim(s) or support(s)\n\nUsage:\n    claim_renew (\noutpoint\n | --outpoint=\noutpoint\n) | (\nheight\n | --height=\nheight\n)\n\n\nOptions:\n    --outpoint=\noutpoint\n  :  (str)  outpoint of the claim to renew\n    --height=\nheight\n      :  (str)  update claims expiring before or at this block height\n\nReturns:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }\n\n\n\n\nclaim_send_to_address\n\n\nSend a name claim to an address\n\nUsage:\n    claim_send_to_address (\nclaim_id\n | --claim_id=\nclaim_id\n)\n                          (\naddress\n | --address=\naddress\n)\n                          [\namount\n | --amount=\namount\n]\n\n\nOptions:\n    --claim_id=\nclaim_id\n  :  (str)  claim_id to send\n    --address=\naddress\n    :  (str)  address to send the claim to\n    --amount\namount\n       :  (int)  Amount of credits to claim name for, defaults to the current amount\n                                     on the claim\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_show\n\n\nResolve claim info from txid/nout or with claim ID\n\nUsage:\n    claim_show [\ntxid\n | --txid=\ntxid\n] [\nnout\n | --nout=\nnout\n]\n               [\nclaim_id\n | --claim_id=\nclaim_id\n]\n\n\nOptions:\n    --txid=\ntxid\n          :  (str)  look for claim with this txid, nout must\n                                     also be specified\n    --nout=\nnout\n          :  (int)  look for claim with this nout, txid must\n                                     also be specified\n    --claim_id=\nclaim_id\n  :  (str)  look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }\n\n\n\n\ncli_test_command\n\n\nThis command is only for testing the CLI argument parsing\nUsage:\n    cli_test_command [--a_arg] [--b_arg] (\npos_arg\n | --pos_arg=\npos_arg\n)\n                     [\npos_args\n...] [--pos_arg2=\npos_arg2\n]\n                     [--pos_arg3=\npos_arg3\n]\n\n\nOptions:\n    --a_arg                :  a    arg\n    --b_arg                :  b    arg\n    --pos_arg=\npos_arg\n    :  pos  arg\n    --pos_args=\npos_args\n  :  pos  args\n    --pos_arg2=\npos_arg2\n  :  pos  arg 2\n    --pos_arg3=\npos_arg3\n  :  pos  arg 3\n\nReturns:\n    pos args\n\n\n\n\ncommands\n\n\nReturn a list of available commands\n\nUsage:\n    commands\n\n\nOptions:\n          None\n\nReturns:\n    (list) list of available commands\n\n\n\n\ndaemon_stop\n\n\nStop lbrynet-daemon\n\nUsage:\n    daemon_stop\n\n\nOptions:\n          None\n\nReturns:\n    (string) Shutdown message\n\n\n\n\nfile_delete\n\n\nDelete a LBRY file\n\nUsage:\n    file_delete [--delete_from_download_dir] [--delete_all] [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n]\n                [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n] [--claim_id=\nclaim_id\n] [--txid=\ntxid\n]\n                [--nout=\nnout\n] [--claim_name=\nclaim_name\n] [--channel_claim_id=\nchannel_claim_id\n]\n                [--channel_name=\nchannel_name\n]\n\n\nOptions:\n    --delete_from_download_dir             :  (bool)  delete file from download directory,\n                                                      instead of just deleting blobs\n    --delete_all                           :  (bool)  if there are multiple matching files,\n                                                      allow the deletion of multiple files.\n                                                      Otherwise do not delete anything.\n    --sd_hash=\nsd_hash\n                    :  (str)   delete by file sd hash\n    --file_name\nfile_name\n                 :  (str)   delete by file name in downloads folder\n    --stream_hash=\nstream_hash\n            :  (str)   delete by file stream hash\n    --rowid=\nrowid\n                        :  (int)   delete by file row id\n    --claim_id=\nclaim_id\n                  :  (str)   delete by file claim id\n    --txid=\ntxid\n                          :  (str)   delete by file claim txid\n    --nout=\nnout\n                          :  (int)   delete by file claim nout\n    --claim_name=\nclaim_name\n              :  (str)   delete by file claim name\n    --channel_claim_id=\nchannel_claim_id\n  :  (str)   delete by file channel claim id\n    --channel_name=\nchannel_name\n          :  (str)   delete by file channel claim name\n\nReturns:\n    (bool) true if deletion was successful\n\n\n\n\nfile_list\n\n\nList files limited by optional filters\n\nUsage:\n    file_list [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n] [--stream_hash=\nstream_hash\n]\n              [--rowid=\nrowid\n] [--claim_id=\nclaim_id\n] [--outpoint=\noutpoint\n] [--txid=\ntxid\n] [--nout=\nnout\n]\n              [--channel_claim_id=\nchannel_claim_id\n] [--channel_name=\nchannel_name\n]\n              [--claim_name=\nclaim_name\n] [--full_status] [--sort=\nsort_method\n...]\n\n\nOptions:\n    --sd_hash=\nsd_hash\n                    :  (str)   get file with matching sd hash\n    --file_name=\nfile_name\n                :  (str)   get file with matching file name in the\n                                                      downloads folder\n    --stream_hash=\nstream_hash\n            :  (str)   get file with matching stream hash\n    --rowid=\nrowid\n                        :  (int)   get file with matching row id\n    --claim_id=\nclaim_id\n                  :  (str)   get file with matching claim id\n    --outpoint=\noutpoint\n                  :  (str)   get file with matching claim outpoint\n    --txid=\ntxid\n                          :  (str)   get file with matching claim txid\n    --nout=\nnout\n                          :  (int)   get file with matching claim nout\n    --channel_claim_id=\nchannel_claim_id\n  :  (str)   get file with matching channel claim id\n    --channel_name=\nchannel_name\n          :  (str)   get file with matching channel name\n    --claim_name=\nclaim_name\n              :  (str)   get file with matching claim name\n    --full_status                          :  (bool)  full status, populate the\n                                                      'message' and 'size' fields\n    --sort=\nsort_method\n                   :  (str)   sort by any property, like 'file_name'\n                                                      or 'metadata.author'; to specify direction\n                                                      append ',asc' or ',desc'\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) num_completed, None if full_status is false,\n            'blobs_in_stream': (int) None if full_status is false,\n            'status': (str) downloader status, None if full_status is false,\n            'claim_id': (str) None if full_status is false or if claim is not found,\n            'outpoint': (str) None if full_status is false or if claim is not found,\n            'txid': (str) None if full_status is false or if claim is not found,\n            'nout': (int) None if full_status is false or if claim is not found,\n            'metadata': (dict) None if full_status is false or if claim is not found,\n            'channel_claim_id': (str) None if full_status is false or if claim is not found or signed,\n            'channel_name': (str) None if full_status is false or if claim is not found or signed,\n            'claim_name': (str) None if full_status is false or if claim is not found\n        },\n    ]\n\n\n\n\nfile_reflect\n\n\nReflect all the blobs in a file matching the filter criteria\n\nUsage:\n    file_reflect [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n]\n                 [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n]\n                 [--reflector=\nreflector\n]\n\n\nOptions:\n    --sd_hash=\nsd_hash\n          :  (str)  get file with matching sd hash\n    --file_name=\nfile_name\n      :  (str)  get file with matching file name in the\n                                           downloads folder\n    --stream_hash=\nstream_hash\n  :  (str)  get file with matching stream hash\n    --rowid=\nrowid\n              :  (int)  get file with matching row id\n    --reflector=\nreflector\n      :  (str)  reflector server, ip address or url\n                                           by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected\n\n\n\n\nfile_set_status\n\n\nStart or stop downloading a file\n\nUsage:\n    file_set_status (\nstatus\n | --status=\nstatus\n) [--sd_hash=\nsd_hash\n]\n              [--file_name=\nfile_name\n] [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n]\n\n\nOptions:\n    --status=\nstatus\n            :  (str)  one of \nstart\n or \nstop\n\n    --sd_hash=\nsd_hash\n          :  (str)  set status of file with matching sd hash\n    --file_name=\nfile_name\n      :  (str)  set status of file with matching file name in the\n                                           downloads folder\n    --stream_hash=\nstream_hash\n  :  (str)  set status of file with matching stream hash\n    --rowid=\nrowid\n              :  (int)  set status of file with matching row id\n\nReturns:\n    (str) Confirmation message\n\n\n\n\nget\n\n\nDownload stream from a LBRY name.\n\nUsage:\n    get \nuri\n [\nfile_name\n | --file_name=\nfile_name\n] [\ntimeout\n | --timeout=\ntimeout\n]\n\n\n\nOptions:\n    --uri=\nuri\n              :  (str)  uri of the content to download\n    --file_name=\nfile_name\n  :  (str)  specified name for the downloaded file\n    --timeout=\ntimeout\n      :  (int)  download timeout in number of seconds\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) num_completed, None if full_status is false,\n        'blobs_in_stream': (int) None if full_status is false,\n        'status': (str) downloader status, None if full_status is false,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }\n\n\n\n\nhelp\n\n\nReturn a useful message for an API command\n\nUsage:\n    help [\ncommand\n | --command=\ncommand\n]\n\n\nOptions:\n    --command=\ncommand\n  :  (str)  command to retrieve documentation for\n\nReturns:\n    (str) Help message\n\n\n\n\npeer_list\n\n\nGet peers for blob hash\n\nUsage:\n    peer_list (\nblob_hash\n | --blob_hash=\nblob_hash\n) [\ntimeout\n | --timeout=\ntimeout\n]\n\n\nOptions:\n    --blob_hash=\nblob_hash\n  :  (str)  find available peers for this blob hash\n    --timeout=\ntimeout\n      :  (int)  peer search timeout in seconds\n\nReturns:\n    (list) List of contact dictionaries {'host': \npeer ip\n, 'port': \npeer port\n, 'node_id': \npeer node id\n}\n\n\n\n\npeer_ping\n\n\nFind and ping a peer by node id\n\nUsage:\n    peer_ping (\nnode_id\n | --node_id=\nnode_id\n)\n\n\nOptions:\n          None\n\nReturns:\n    (str) pong, or {'error': \nerror message\n} if an error is encountered\n\n\n\n\npublish\n\n\nMake a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nUsage:\n    publish (\nname\n | --name=\nname\n) (\nbid\n | --bid=\nbid\n) [--metadata=\nmetadata\n]\n            [--file_path=\nfile_path\n] [--fee=\nfee\n] [--title=\ntitle\n]\n            [--description=\ndescription\n] [--author=\nauthor\n] [--language=\nlanguage\n]\n            [--license=\nlicense\n] [--license_url=\nlicense_url\n] [--thumbnail=\nthumbnail\n]\n            [--preview=\npreview\n] [--nsfw=\nnsfw\n] [--sources=\nsources\n]\n            [--channel_name=\nchannel_name\n] [--channel_id=\nchannel_id\n]\n            [--claim_address=\nclaim_address\n] [--change_address=\nchange_address\n]\n\n\nOptions:\n    --name=\nname\n                    :  (str)      name of the content\n    --bid=\nbid\n                      :  (decimal)  amount to back the claim\n    --metadata=\nmetadata\n            :  (dict)     ClaimDict to associate with the claim.\n    --file_path=\nfile_path\n          :  (str)      path to file to be associated with name. If provided,\n                                                   a lbry stream of this file will be used in 'sources'.\n                                                   If no path is given but a sources dict is provided,\n                                                   it will be used. If neither are provided, an\n                                                   error is raised.\n    --fee=\nfee\n                      :  (dict)     Dictionary representing key fee to download content:\n                                                   {\n                                                   'currency': currency_symbol,\n                                                   'amount': decimal,\n                                                   'address': str, optional\n                                                   }\n                                                   supported currencies: LBC, USD, BTC\n                                                   If an address is not provided a new one will be\n                                                   automatically generated. Default fee is zero.\n    --title=\ntitle\n                  :  (str)      title of the publication\n    --description=\ndescription\n      :  (str)      description of the publication\n    --author=\nauthor\n                :  (str)      author of the publication\n    --language=\nlanguage\n            :  (str)      language of the publication\n    --license=\nlicense\n              :  (str)      publication license\n    --license_url=\nlicense_url\n      :  (str)      publication license url\n    --thumbnail=\nthumbnail\n          :  (str)      thumbnail url\n    --preview=\npreview\n              :  (str)      preview url\n    --nsfw=\nnsfw\n                    :  (bool)     whether the content is nsfw\n    --sources=\nsources\n              :  (str)      {'lbry_sd_hash': sd_hash} specifies sd hash of file\n    --channel_name=\nchannel_name\n    :  (str)      name of the publisher channel name in the wallet\n    --channel_id=\nchannel_id\n        :  (str)      claim id of the publisher channel, does not check\n                                                   for channel claim being in the wallet. This allows\n                                                   publishing to a channel where only the certificate\n                                                   private key is in the wallet.\n    --claim_address=\nclaim_address\n  :  (str)      address where the claim is sent to, if not specified\n                                                   new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nreport_bug\n\n\nReport a bug to slack\n\nUsage:\n    report_bug (\nmessage\n | --message=\nmessage\n)\n\n\nOptions:\n    --message=\nmessage\n  :  (str)  Description of the bug\n\nReturns:\n    (bool) true if successful\n\n\n\n\nresolve\n\n\nResolve given LBRY URIs\n\nUsage:\n    resolve [--force] (\nuri\n | --uri=\nuri\n) [\nuris\n...]\n\n\nOptions:\n    --force        :  (bool)  force refresh and ignore cache\n    --uri=\nuri\n    :  (str)   uri to resolve\n    --uris=\nuris\n  :  (list)  uris to resolve\n\nReturns:\n    Dictionary of results, keyed by uri\n    '\nuri\n': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }\n\n\n\n\nresolve_name\n\n\nResolve stream info from a LBRY name\n\nUsage:\n    resolve_name (\nname\n | --name=\nname\n) [--force]\n\n\nOptions:\n    --name=\nname\n  :  (str)   the name to resolve\n    --force        :  (bool)  force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable\n\n\n\n\nrouting_table_get\n\n\nGet DHT routing information\n\nUsage:\n    routing_table_get\n\n\nOptions:\n          None\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n        \nbuckets\n: {\n            \nbucket index\n: [\n                {\n                    \naddress\n: (str) peer address,\n                    \nport\n: (int) peer udp port\n                    \nnode_id\n: (str) peer node id,\n                    \nblobs\n: (list) blob hashes announced by peer\n                }\n            ]\n        },\n        \ncontacts\n: (list) contact node ids,\n        \nblob_hashes\n: (list) all of the blob hashes stored by peers in the list of buckets,\n        \nnode_id\n: (str) the local dht node id\n    }\n\n\n\n\nsettings_get\n\n\nGet daemon settings\n\nUsage:\n    settings_get\n\n\nOptions:\n          None\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings\n\n\n\n\nsettings_set\n\n\nSet daemon settings\n\nUsage:\n    settings_set [--download_directory=\ndownload_directory\n]\n                 [--data_rate=\ndata_rate\n]\n                 [--download_timeout=\ndownload_timeout\n]\n                 [--peer_port=\npeer_port\n]\n                 [--max_key_fee=\nmax_key_fee\n]\n                 [--disable_max_key_fee=\ndisable_max_key_fee\n]\n                 [--use_upnp=\nuse_upnp\n]\n                 [--run_reflector_server=\nrun_reflector_server\n]\n                 [--cache_time=\ncache_time\n]\n                 [--reflect_uploads=\nreflect_uploads\n]\n                 [--share_usage_data=\nshare_usage_data\n]\n                 [--peer_search_timeout=\npeer_search_timeout\n]\n                 [--sd_download_timeout=\nsd_download_timeout\n]\n                 [--auto_renew_claim_height_delta=\nauto_renew_claim_height_delta\n]\n\n\nOptions:\n    --download_directory=\ndownload_directory\n                        :  (str)    path of download directory\n    --data_rate=\ndata_rate\n                                          :  (float)  0.0001\n    --download_timeout=\ndownload_timeout\n                            :  (int)    180\n    --peer_port=\npeer_port\n                                          :  (int)    3333\n    --max_key_fee=\nmax_key_fee\n                                      :  (dict)   maximum key fee for downloads,\n                                                                                 in the format:\n                                                                                 {\n                                                                                 'currency': \ncurrency_symbol\n,\n                                                                                 'amount': \namount\n\n                                                                                 }.\n                                                                                 In the CLI, it must be an escaped JSON string\n                                                                                 Supported currency symbols: LBC, USD, BTC\n    --disable_max_key_fee=\ndisable_max_key_fee\n                      :  (bool)   False\n    --use_upnp=\nuse_upnp\n                                            :  (bool)   True\n    --run_reflector_server=\nrun_reflector_server\n                    :  (bool)   False\n    --cache_time=\ncache_time\n                                        :  (int)    150\n    --reflect_uploads=\nreflect_uploads\n                              :  (bool)   True\n    --share_usage_data=\nshare_usage_data\n                            :  (bool)   True\n    --peer_search_timeout=\npeer_search_timeout\n                      :  (int)    3\n    --sd_download_timeout=\nsd_download_timeout\n                      :  (int)    3\n    --auto_renew_claim_height_delta=\nauto_renew_claim_height_delta\n  :  (int)    0\n                                                                                 claims set to expire within this many blocks will be\n                                                                                 automatically renewed after startup (if set to 0, renews\n                                                                                 will not be made automatically)\n\nReturns:\n    (dict) Updated dictionary of daemon settings\n\n\n\n\nstatus\n\n\nGet daemon status\n\nUsage:\n    status [--session_status]\n\n\nOptions:\n    --session_status  :  (bool)  include session status in results\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58,\n        'installation_id': installation id, base58,\n        'is_running': bool,\n        'is_first_run': bool,\n        'startup_status': {\n            'code': status code,\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code,\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n        'wallet_is_encrypted': bool,\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n    }\n\n\n\n\nstream_availability\n\n\nGet stream availability for lbry uri\n\nUsage:\n    stream_availability (\nuri\n | --uri=\nuri\n)\n                        [\nsearch_timeout\n | --search_timeout=\nsearch_timeout\n]\n                        [\nblob_timeout\n | --blob_timeout=\nblob_timeout\n]\n\n\nOptions:\n    --uri=\nuri\n                        :  (str)  check availability for this uri\n    --search_timeout=\nsearch_timeout\n  :  (int)  how long to search for peers for the blob\n                                                 in the dht\n    --blob_timeout=\nblob_timeout\n      :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        'is_available': \nbool\n,\n        'did_decode': \nbool\n,\n        'did_resolve': \nbool\n,\n        'is_stream': \nbool\n,\n        'num_blobs_in_stream': \nint\n,\n        'sd_hash': \nstr\n,\n        'sd_blob_availability': \ndict\n see `blob_availability`,\n        'head_blob_hash': \nstr\n,\n        'head_blob_availability': \ndict\n see `blob_availability`,\n        'use_upnp': \nbool\n,\n        'upnp_redirect_is_set': \nbool\n,\n        'error': \nNone\n | \nstr\n error message\n    }\n\n\n\n\nstream_cost_estimate\n\n\nGet estimated cost for a lbry stream\n\nUsage:\n    stream_cost_estimate (\nuri\n | --uri=\nuri\n) [\nsize\n | --size=\nsize\n]\n\n\nOptions:\n    --uri=\nuri\n    :  (str)    uri to use\n    --size=\nsize\n  :  (float)  stream size in bytes. if provided an sd blob won't be\n                               downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable\n\n\n\n\ntransaction_list\n\n\nList transactions belonging to wallet\n\nUsage:\n    transaction_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of transactions\n\n    {\n        \nclaim_info\n: (list) claim info if in txn [{\n                                                \naddress\n: (str) address of claim,\n                                                \nbalance_delta\n: (float) bid amount,\n                                                \namount\n: (float) claim amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nabandon_info\n: (list) abandon info if in txn [{\n                                                \naddress\n: (str) address of abandoned claim,\n                                                \nbalance_delta\n: (float) returned amount,\n                                                \namount\n: (float) claim amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nconfirmations\n: (int) number of confirmations for the txn,\n        \ndate\n: (str) date and time of txn,\n        \nfee\n: (float) txn fee,\n        \nsupport_info\n: (list) support info if in txn [{\n                                                \naddress\n: (str) address of support,\n                                                \nbalance_delta\n: (float) support amount,\n                                                \namount\n: (float) support amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nis_tip\n: (bool),\n                                                \nnout\n: (int) nout\n                                                }],\n        \ntimestamp\n: (int) timestamp,\n        \ntxid\n: (str) txn id,\n        \nupdate_info\n: (list) update info if in txn [{\n                                                \naddress\n: (str) address of claim,\n                                                \nbalance_delta\n: (float) credited/debited\n                                                \namount\n: (float) absolute amount,\n                                                \nclaim_id\n: (str) claim id,\n                                                \nclaim_name\n: (str) claim name,\n                                                \nnout\n: (int) nout\n                                                }],\n        \nvalue\n: (float) value of txn\n    }\n\n\n\n\ntransaction_show\n\n\nGet a decoded transaction from a txid\n\nUsage:\n    transaction_show (\ntxid\n | --txid=\ntxid\n)\n\n\nOptions:\n    --txid=\ntxid\n  :  (str)  txid of the transaction\n\nReturns:\n    (dict) JSON formatted transaction\n\n\n\n\nutxo_list\n\n\nList unspent transaction outputs\n\nUsage:\n    utxo_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n            \naddress\n: (str) the output address\n            \namount\n: (float) unspent amount\n            \nheight\n: (int) block height\n            \nis_claim\n: (bool) is the tx a claim\n            \nis_coinbase\n: (bool) is the tx a coinbase tx\n            \nis_support\n: (bool) is the tx a support\n            \nis_update\n: (bool) is the tx an update\n            \nnout\n: (int) nout of the output\n            \ntxid\n: (str) txid of the output\n        },\n        ...\n    ]\n\n\n\n\nversion\n\n\nGet lbry version information\n\nUsage:\n    version\n\n\nOptions:\n          None\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \ndev\n, \nrc\n, \nrelease\n),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }\n\n\n\n\nwallet_balance\n\n\nReturn the balance of the wallet\n\nUsage:\n    wallet_balance [\naddress\n | --address=\naddress\n] [--include_unconfirmed]\n\n\nOptions:\n    --address=\naddress\n    :  (str)   If provided only the balance for this\n                                      address will be given\n    --include_unconfirmed  :  (bool)  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet\n\n\n\n\nwallet_decrypt\n\n\nDecrypt an encrypted wallet, this will remove the wallet password\n\nUsage:\n    wallet_decrypt\n\n\nOptions:\n          None\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false\n\n\n\n\nwallet_encrypt\n\n\nEncrypt a wallet with a password, if the wallet is already encrypted this will update\nthe password\n\nUsage:\n    wallet_encrypt (\nnew_password\n | --new_password=\nnew_password\n)\n\n\nOptions:\n    --new_password=\nnew_password\n  :  (str)  password string to be used for encrypting wallet\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false\n\n\n\n\nwallet_is_address_mine\n\n\nChecks if an address is associated with the current wallet.\n\nUsage:\n    wallet_is_address_mine (\naddress\n | --address=\naddress\n)\n\n\nOptions:\n    --address=\naddress\n  :  (str)  address to check\n\nReturns:\n    (bool) true, if address is associated with current wallet\n\n\n\n\nwallet_list\n\n\nList wallet addresses\n\nUsage:\n    wallet_list\n\n\nOptions:\n          None\n\nReturns:\n    List of wallet addresses\n\n\n\n\nwallet_new_address\n\n\nGenerate a new wallet address\n\nUsage:\n    wallet_new_address\n\n\nOptions:\n          None\n\nReturns:\n    (str) New wallet address in base58\n\n\n\n\nwallet_prefill_addresses\n\n\nCreate new addresses, each containing `amount` credits\n\nUsage:\n    wallet_prefill_addresses [--no_broadcast]\n                             (\nnum_addresses\n | --num_addresses=\nnum_addresses\n)\n                             (\namount\n | --amount=\namount\n)\n\n\nOptions:\n    --no_broadcast                   :  (bool)   whether to broadcast or not\n    --num_addresses=\nnum_addresses\n  :  (int)    num of addresses to create\n    --amount=\namount\n                :  (float)  initial amount in each address\n\nReturns:\n    (dict) the resulting transaction\n\n\n\n\nwallet_public_key\n\n\nGet public key from wallet address\n\nUsage:\n    wallet_public_key (\naddress\n | --address=\naddress\n)\n\n\nOptions:\n    --address=\naddress\n  :  (str)  address for which to get the public key\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.\n\n\n\n\nwallet_send\n\n\nSend credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nUsage:\n    wallet_send (\namount\n | --amount=\namount\n)\n                ((\naddress\n | --address=\naddress\n) | (\nclaim_id\n | --claim_id=\nclaim_id\n))\n\n\nOptions:\n    --amount=\namount\n      :  (float)  amount of credit to send\n    --address=\naddress\n    :  (str)    address to send credits to\n    --claim_id=\nclaim_id\n  :  (float)  claim_id of the claim to send to tip to\n\nReturns:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nwallet_unlock\n\n\nUnlock an encrypted wallet\n\nUsage:\n    wallet_unlock (\npassword\n | --password=\npassword\n)\n\n\nOptions:\n    --password=\npassword\n  :  (str)  password for unlocking wallet\n\nReturns:\n    (bool) true if wallet is unlocked, otherwise false\n\n\n\n\nwallet_unused_address\n\n\nReturn an address containing no balance, will create\na new address if there is none.\n\nUsage:\n    wallet_unused_address\n\n\nOptions:\n          None\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "CLI"
        }, 
        {
            "location": "/cli/#lbry-json-rpc-api-documentation", 
            "text": "", 
            "title": "LBRY JSON-RPC API Documentation"
        }, 
        {
            "location": "/cli/#blob_announce", 
            "text": "Announce blobs to the DHT\n\nUsage:\n    blob_announce [ blob_hash  | --blob_hash= blob_hash ]\n                  [ stream_hash  | --stream_hash= stream_hash ] | [ sd_hash  | --sd_hash= sd_hash ]\n\n\nOptions:\n    --blob_hash= blob_hash       :  (str)  announce a blob, specified by blob_hash\n    --stream_hash= stream_hash   :  (str)  announce all blobs associated with\n                                           stream_hash\n    --sd_hash= sd_hash           :  (str)  announce all blobs associated with\n                                           sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_announce"
        }, 
        {
            "location": "/cli/#blob_availability", 
            "text": "Get blob availability\n\nUsage:\n    blob_availability ( blob_hash ) [ search_timeout  | --search_timeout= search_timeout ]\n                      [ blob_timeout  | --blob_timeout= blob_timeout ]\n\n\nOptions:\n    --blob_hash= blob_hash             :  (str)  check availability for this blob hash\n    --search_timeout= search_timeout   :  (int)  how long to search for peers for the blob\n                                                 in the dht\n    --blob_timeout= blob_timeout       :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n         is_available :  bool, true if blob is available from a peer from peer list \n         reachable_peers : [ ip : port ],\n         unreachable_peers : [ ip : port ]\n    }", 
            "title": "blob_availability"
        }, 
        {
            "location": "/cli/#blob_delete", 
            "text": "Delete a blob\n\nUsage:\n    blob_delete ( blob_hash  | --blob_hash= blob_hash)\n\n\nOptions:\n    --blob_hash= blob_hash   :  (str)  blob hash of the blob to delete\n\nReturns:\n    (str) Success/fail message", 
            "title": "blob_delete"
        }, 
        {
            "location": "/cli/#blob_get", 
            "text": "Download and return a blob\n\nUsage:\n    blob_get ( blob_hash  | --blob_hash= blob_hash ) [--timeout= timeout ]\n             [--encoding= encoding ] [--payment_rate_manager= payment_rate_manager ]\n\n\nOptions:\n    --blob_hash= blob_hash                         :  (str)  blob hash of the blob to get\n    --timeout= timeout                             :  (int)  timeout in number of seconds\n    --encoding= encoding                           :  (str)  by default no attempt at decoding\n                                                             is made, can be set to one of the\n                                                             following decoders:\n                                                             'json'\n    --payment_rate_manager= payment_rate_manager   :  (str)  if not given the default payment rate\n                                                             manager will be used.\n                                                             supported alternative rate managers:\n                                                             'only-free'\n\nReturns:\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "blob_get"
        }, 
        {
            "location": "/cli/#blob_list", 
            "text": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nUsage:\n    blob_list [--needed] [--finished] [ uri  | --uri= uri ]\n              [ stream_hash  | --stream_hash= stream_hash ]\n              [ sd_hash  | --sd_hash= sd_hash ]\n              [ page_size  | --page_size= page_size ]\n              [ page  | --page= page ]\n\n\nOptions:\n    --needed                     :  (bool)  only return needed blobs\n    --finished                   :  (bool)  only return finished blobs\n    --uri= uri                   :  (str)   filter blobs by stream in a uri\n    --stream_hash= stream_hash   :  (str)   filter blobs by stream hash\n    --sd_hash= sd_hash           :  (str)   filter blobs by sd hash\n    --page_size= page_size       :  (int)   results page size\n    --page= page                 :  (int)   page of results to return\n\nReturns:\n    (list) List of blob hashes", 
            "title": "blob_list"
        }, 
        {
            "location": "/cli/#blob_reflect", 
            "text": "Reflects specified blobs\n\nUsage:\n    blob_reflect ( blob_hashes ...) [--reflector_server= reflector_server ]\n\n\nOptions:\n    --reflector_server= reflector_server   :  (str)  reflector address\n\nReturns:\n    (list) reflected blob hashes", 
            "title": "blob_reflect"
        }, 
        {
            "location": "/cli/#blob_reflect_all", 
            "text": "Reflects all saved blobs\n\nUsage:\n    blob_reflect_all\n\n\nOptions:\n          None\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_reflect_all"
        }, 
        {
            "location": "/cli/#block_show", 
            "text": "Get contents of a block\n\nUsage:\n    block_show ( blockhash  | --blockhash= blockhash ) | ( height  | --height= height )\n\n\nOptions:\n    --blockhash= blockhash   :  (str)  hash of the block to look up\n    --height= height         :  (int)  height of the block to look up\n\nReturns:\n    (dict) Requested block", 
            "title": "block_show"
        }, 
        {
            "location": "/cli/#channel_export", 
            "text": "Export serialized channel signing information for a given certificate claim id\n\nUsage:\n    channel_export ( claim_id  | --claim_id= claim_id )\n\n\nOptions:\n    --claim_id= claim_id   :  (str)  Claim ID to export information about\n\nReturns:\n    (str) Serialized certificate information", 
            "title": "channel_export"
        }, 
        {
            "location": "/cli/#channel_import", 
            "text": "Import serialized channel signing information (to allow signing new claims to the channel)\n\nUsage:\n    channel_import ( serialized_certificate_info  | --serialized_certificate_info= serialized_certificate_info )\n\n\nOptions:\n    --serialized_certificate_info= serialized_certificate_info   :  (str)  certificate info\n\nReturns:\n    (dict) Result dictionary", 
            "title": "channel_import"
        }, 
        {
            "location": "/cli/#channel_list", 
            "text": "Get certificate claim infos for channels that can be published to\n\nUsage:\n    channel_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.", 
            "title": "channel_list"
        }, 
        {
            "location": "/cli/#channel_new", 
            "text": "Generate a publisher key and create a new '@' prefixed certificate claim\n\nUsage:\n    channel_new ( channel_name  | --channel_name= channel_name )\n                ( amount  | --amount= amount )\n\n\nOptions:\n    --channel_name= channel_name   :  (str)    name of the channel prefixed with '@'\n    --amount= amount               :  (float)  bid amount on the channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "channel_new"
        }, 
        {
            "location": "/cli/#claim_abandon", 
            "text": "Abandon a name and reclaim credits from the claim\n\nUsage:\n    claim_abandon [ claim_id  | --claim_id= claim_id ]\n                  [ txid  | --txid= txid ] [ nout  | --nout= nout ]\n\n\nOptions:\n    --claim_id= claim_id   :  (str)  claim_id of the claim to abandon\n    --txid= txid           :  (str)  txid of the claim to abandon\n    --nout= nout           :  (int)  nout of the claim to abandon\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_abandon"
        }, 
        {
            "location": "/cli/#claim_list", 
            "text": "List current claims and information about them for a given name\n\nUsage:\n    claim_list ( name  | --name= name )\n\n\nOptions:\n    --name= name   :  (str)  name of the claim to list info about\n\nReturns:\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }", 
            "title": "claim_list"
        }, 
        {
            "location": "/cli/#claim_list_by_channel", 
            "text": "Get paginated claims in a channel specified by a channel uri\n\nUsage:\n    claim_list_by_channel ( uri  | --uri= uri ) [ uris ...] [--page= page ]\n                           [--page_size= page_size ]\n\n\nOptions:\n    --uri= uri               :  (str)   uri of the channel\n    --uris= uris             :  (list)  uris of the channel\n    --page= page             :  (int)   which page of results to return where page 1 is the first\n                                        page, defaults to no pages\n    --page_size= page_size   :  (int)   number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }", 
            "title": "claim_list_by_channel"
        }, 
        {
            "location": "/cli/#claim_list_mine", 
            "text": "List my name claims\n\nUsage:\n    claim_list_mine\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str)  claim ,  update  , or  support \n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]", 
            "title": "claim_list_mine"
        }, 
        {
            "location": "/cli/#claim_new_support", 
            "text": "Support a name claim\n\nUsage:\n    claim_new_support ( name  | --name= name ) ( claim_id  | --claim_id= claim_id )\n                      ( amount  | --amount= amount )\n\n\nOptions:\n    --name= name           :  (str)    name of the claim to support\n    --claim_id= claim_id   :  (str)    claim_id of the claim to support\n    --amount= amount       :  (float)  amount of support\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_new_support"
        }, 
        {
            "location": "/cli/#claim_renew", 
            "text": "Renew claim(s) or support(s)\n\nUsage:\n    claim_renew ( outpoint  | --outpoint= outpoint ) | ( height  | --height= height )\n\n\nOptions:\n    --outpoint= outpoint   :  (str)  outpoint of the claim to renew\n    --height= height       :  (str)  update claims expiring before or at this block height\n\nReturns:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }", 
            "title": "claim_renew"
        }, 
        {
            "location": "/cli/#claim_send_to_address", 
            "text": "Send a name claim to an address\n\nUsage:\n    claim_send_to_address ( claim_id  | --claim_id= claim_id )\n                          ( address  | --address= address )\n                          [ amount  | --amount= amount ]\n\n\nOptions:\n    --claim_id= claim_id   :  (str)  claim_id to send\n    --address= address     :  (str)  address to send the claim to\n    --amount amount        :  (int)  Amount of credits to claim name for, defaults to the current amount\n                                     on the claim\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "claim_send_to_address"
        }, 
        {
            "location": "/cli/#claim_show", 
            "text": "Resolve claim info from txid/nout or with claim ID\n\nUsage:\n    claim_show [ txid  | --txid= txid ] [ nout  | --nout= nout ]\n               [ claim_id  | --claim_id= claim_id ]\n\n\nOptions:\n    --txid= txid           :  (str)  look for claim with this txid, nout must\n                                     also be specified\n    --nout= nout           :  (int)  look for claim with this nout, txid must\n                                     also be specified\n    --claim_id= claim_id   :  (str)  look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }", 
            "title": "claim_show"
        }, 
        {
            "location": "/cli/#cli_test_command", 
            "text": "This command is only for testing the CLI argument parsing\nUsage:\n    cli_test_command [--a_arg] [--b_arg] ( pos_arg  | --pos_arg= pos_arg )\n                     [ pos_args ...] [--pos_arg2= pos_arg2 ]\n                     [--pos_arg3= pos_arg3 ]\n\n\nOptions:\n    --a_arg                :  a    arg\n    --b_arg                :  b    arg\n    --pos_arg= pos_arg     :  pos  arg\n    --pos_args= pos_args   :  pos  args\n    --pos_arg2= pos_arg2   :  pos  arg 2\n    --pos_arg3= pos_arg3   :  pos  arg 3\n\nReturns:\n    pos args", 
            "title": "cli_test_command"
        }, 
        {
            "location": "/cli/#commands", 
            "text": "Return a list of available commands\n\nUsage:\n    commands\n\n\nOptions:\n          None\n\nReturns:\n    (list) list of available commands", 
            "title": "commands"
        }, 
        {
            "location": "/cli/#daemon_stop", 
            "text": "Stop lbrynet-daemon\n\nUsage:\n    daemon_stop\n\n\nOptions:\n          None\n\nReturns:\n    (string) Shutdown message", 
            "title": "daemon_stop"
        }, 
        {
            "location": "/cli/#file_delete", 
            "text": "Delete a LBRY file\n\nUsage:\n    file_delete [--delete_from_download_dir] [--delete_all] [--sd_hash= sd_hash ] [--file_name= file_name ]\n                [--stream_hash= stream_hash ] [--rowid= rowid ] [--claim_id= claim_id ] [--txid= txid ]\n                [--nout= nout ] [--claim_name= claim_name ] [--channel_claim_id= channel_claim_id ]\n                [--channel_name= channel_name ]\n\n\nOptions:\n    --delete_from_download_dir             :  (bool)  delete file from download directory,\n                                                      instead of just deleting blobs\n    --delete_all                           :  (bool)  if there are multiple matching files,\n                                                      allow the deletion of multiple files.\n                                                      Otherwise do not delete anything.\n    --sd_hash= sd_hash                     :  (str)   delete by file sd hash\n    --file_name file_name                  :  (str)   delete by file name in downloads folder\n    --stream_hash= stream_hash             :  (str)   delete by file stream hash\n    --rowid= rowid                         :  (int)   delete by file row id\n    --claim_id= claim_id                   :  (str)   delete by file claim id\n    --txid= txid                           :  (str)   delete by file claim txid\n    --nout= nout                           :  (int)   delete by file claim nout\n    --claim_name= claim_name               :  (str)   delete by file claim name\n    --channel_claim_id= channel_claim_id   :  (str)   delete by file channel claim id\n    --channel_name= channel_name           :  (str)   delete by file channel claim name\n\nReturns:\n    (bool) true if deletion was successful", 
            "title": "file_delete"
        }, 
        {
            "location": "/cli/#file_list", 
            "text": "List files limited by optional filters\n\nUsage:\n    file_list [--sd_hash= sd_hash ] [--file_name= file_name ] [--stream_hash= stream_hash ]\n              [--rowid= rowid ] [--claim_id= claim_id ] [--outpoint= outpoint ] [--txid= txid ] [--nout= nout ]\n              [--channel_claim_id= channel_claim_id ] [--channel_name= channel_name ]\n              [--claim_name= claim_name ] [--full_status] [--sort= sort_method ...]\n\n\nOptions:\n    --sd_hash= sd_hash                     :  (str)   get file with matching sd hash\n    --file_name= file_name                 :  (str)   get file with matching file name in the\n                                                      downloads folder\n    --stream_hash= stream_hash             :  (str)   get file with matching stream hash\n    --rowid= rowid                         :  (int)   get file with matching row id\n    --claim_id= claim_id                   :  (str)   get file with matching claim id\n    --outpoint= outpoint                   :  (str)   get file with matching claim outpoint\n    --txid= txid                           :  (str)   get file with matching claim txid\n    --nout= nout                           :  (int)   get file with matching claim nout\n    --channel_claim_id= channel_claim_id   :  (str)   get file with matching channel claim id\n    --channel_name= channel_name           :  (str)   get file with matching channel name\n    --claim_name= claim_name               :  (str)   get file with matching claim name\n    --full_status                          :  (bool)  full status, populate the\n                                                      'message' and 'size' fields\n    --sort= sort_method                    :  (str)   sort by any property, like 'file_name'\n                                                      or 'metadata.author'; to specify direction\n                                                      append ',asc' or ',desc'\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) num_completed, None if full_status is false,\n            'blobs_in_stream': (int) None if full_status is false,\n            'status': (str) downloader status, None if full_status is false,\n            'claim_id': (str) None if full_status is false or if claim is not found,\n            'outpoint': (str) None if full_status is false or if claim is not found,\n            'txid': (str) None if full_status is false or if claim is not found,\n            'nout': (int) None if full_status is false or if claim is not found,\n            'metadata': (dict) None if full_status is false or if claim is not found,\n            'channel_claim_id': (str) None if full_status is false or if claim is not found or signed,\n            'channel_name': (str) None if full_status is false or if claim is not found or signed,\n            'claim_name': (str) None if full_status is false or if claim is not found\n        },\n    ]", 
            "title": "file_list"
        }, 
        {
            "location": "/cli/#file_reflect", 
            "text": "Reflect all the blobs in a file matching the filter criteria\n\nUsage:\n    file_reflect [--sd_hash= sd_hash ] [--file_name= file_name ]\n                 [--stream_hash= stream_hash ] [--rowid= rowid ]\n                 [--reflector= reflector ]\n\n\nOptions:\n    --sd_hash= sd_hash           :  (str)  get file with matching sd hash\n    --file_name= file_name       :  (str)  get file with matching file name in the\n                                           downloads folder\n    --stream_hash= stream_hash   :  (str)  get file with matching stream hash\n    --rowid= rowid               :  (int)  get file with matching row id\n    --reflector= reflector       :  (str)  reflector server, ip address or url\n                                           by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected", 
            "title": "file_reflect"
        }, 
        {
            "location": "/cli/#file_set_status", 
            "text": "Start or stop downloading a file\n\nUsage:\n    file_set_status ( status  | --status= status ) [--sd_hash= sd_hash ]\n              [--file_name= file_name ] [--stream_hash= stream_hash ] [--rowid= rowid ]\n\n\nOptions:\n    --status= status             :  (str)  one of  start  or  stop \n    --sd_hash= sd_hash           :  (str)  set status of file with matching sd hash\n    --file_name= file_name       :  (str)  set status of file with matching file name in the\n                                           downloads folder\n    --stream_hash= stream_hash   :  (str)  set status of file with matching stream hash\n    --rowid= rowid               :  (int)  set status of file with matching row id\n\nReturns:\n    (str) Confirmation message", 
            "title": "file_set_status"
        }, 
        {
            "location": "/cli/#get", 
            "text": "Download stream from a LBRY name.\n\nUsage:\n    get  uri  [ file_name  | --file_name= file_name ] [ timeout  | --timeout= timeout ]\n\n\n\nOptions:\n    --uri= uri               :  (str)  uri of the content to download\n    --file_name= file_name   :  (str)  specified name for the downloaded file\n    --timeout= timeout       :  (int)  download timeout in number of seconds\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) num_completed, None if full_status is false,\n        'blobs_in_stream': (int) None if full_status is false,\n        'status': (str) downloader status, None if full_status is false,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }", 
            "title": "get"
        }, 
        {
            "location": "/cli/#help", 
            "text": "Return a useful message for an API command\n\nUsage:\n    help [ command  | --command= command ]\n\n\nOptions:\n    --command= command   :  (str)  command to retrieve documentation for\n\nReturns:\n    (str) Help message", 
            "title": "help"
        }, 
        {
            "location": "/cli/#peer_list", 
            "text": "Get peers for blob hash\n\nUsage:\n    peer_list ( blob_hash  | --blob_hash= blob_hash ) [ timeout  | --timeout= timeout ]\n\n\nOptions:\n    --blob_hash= blob_hash   :  (str)  find available peers for this blob hash\n    --timeout= timeout       :  (int)  peer search timeout in seconds\n\nReturns:\n    (list) List of contact dictionaries {'host':  peer ip , 'port':  peer port , 'node_id':  peer node id }", 
            "title": "peer_list"
        }, 
        {
            "location": "/cli/#peer_ping", 
            "text": "Find and ping a peer by node id\n\nUsage:\n    peer_ping ( node_id  | --node_id= node_id )\n\n\nOptions:\n          None\n\nReturns:\n    (str) pong, or {'error':  error message } if an error is encountered", 
            "title": "peer_ping"
        }, 
        {
            "location": "/cli/#publish", 
            "text": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nUsage:\n    publish ( name  | --name= name ) ( bid  | --bid= bid ) [--metadata= metadata ]\n            [--file_path= file_path ] [--fee= fee ] [--title= title ]\n            [--description= description ] [--author= author ] [--language= language ]\n            [--license= license ] [--license_url= license_url ] [--thumbnail= thumbnail ]\n            [--preview= preview ] [--nsfw= nsfw ] [--sources= sources ]\n            [--channel_name= channel_name ] [--channel_id= channel_id ]\n            [--claim_address= claim_address ] [--change_address= change_address ]\n\n\nOptions:\n    --name= name                     :  (str)      name of the content\n    --bid= bid                       :  (decimal)  amount to back the claim\n    --metadata= metadata             :  (dict)     ClaimDict to associate with the claim.\n    --file_path= file_path           :  (str)      path to file to be associated with name. If provided,\n                                                   a lbry stream of this file will be used in 'sources'.\n                                                   If no path is given but a sources dict is provided,\n                                                   it will be used. If neither are provided, an\n                                                   error is raised.\n    --fee= fee                       :  (dict)     Dictionary representing key fee to download content:\n                                                   {\n                                                   'currency': currency_symbol,\n                                                   'amount': decimal,\n                                                   'address': str, optional\n                                                   }\n                                                   supported currencies: LBC, USD, BTC\n                                                   If an address is not provided a new one will be\n                                                   automatically generated. Default fee is zero.\n    --title= title                   :  (str)      title of the publication\n    --description= description       :  (str)      description of the publication\n    --author= author                 :  (str)      author of the publication\n    --language= language             :  (str)      language of the publication\n    --license= license               :  (str)      publication license\n    --license_url= license_url       :  (str)      publication license url\n    --thumbnail= thumbnail           :  (str)      thumbnail url\n    --preview= preview               :  (str)      preview url\n    --nsfw= nsfw                     :  (bool)     whether the content is nsfw\n    --sources= sources               :  (str)      {'lbry_sd_hash': sd_hash} specifies sd hash of file\n    --channel_name= channel_name     :  (str)      name of the publisher channel name in the wallet\n    --channel_id= channel_id         :  (str)      claim id of the publisher channel, does not check\n                                                   for channel claim being in the wallet. This allows\n                                                   publishing to a channel where only the certificate\n                                                   private key is in the wallet.\n    --claim_address= claim_address   :  (str)      address where the claim is sent to, if not specified\n                                                   new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "publish"
        }, 
        {
            "location": "/cli/#report_bug", 
            "text": "Report a bug to slack\n\nUsage:\n    report_bug ( message  | --message= message )\n\n\nOptions:\n    --message= message   :  (str)  Description of the bug\n\nReturns:\n    (bool) true if successful", 
            "title": "report_bug"
        }, 
        {
            "location": "/cli/#resolve", 
            "text": "Resolve given LBRY URIs\n\nUsage:\n    resolve [--force] ( uri  | --uri= uri ) [ uris ...]\n\n\nOptions:\n    --force        :  (bool)  force refresh and ignore cache\n    --uri= uri     :  (str)   uri to resolve\n    --uris= uris   :  (list)  uris to resolve\n\nReturns:\n    Dictionary of results, keyed by uri\n    ' uri ': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }", 
            "title": "resolve"
        }, 
        {
            "location": "/cli/#resolve_name", 
            "text": "Resolve stream info from a LBRY name\n\nUsage:\n    resolve_name ( name  | --name= name ) [--force]\n\n\nOptions:\n    --name= name   :  (str)   the name to resolve\n    --force        :  (bool)  force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable", 
            "title": "resolve_name"
        }, 
        {
            "location": "/cli/#routing_table_get", 
            "text": "Get DHT routing information\n\nUsage:\n    routing_table_get\n\n\nOptions:\n          None\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n         buckets : {\n             bucket index : [\n                {\n                     address : (str) peer address,\n                     port : (int) peer udp port\n                     node_id : (str) peer node id,\n                     blobs : (list) blob hashes announced by peer\n                }\n            ]\n        },\n         contacts : (list) contact node ids,\n         blob_hashes : (list) all of the blob hashes stored by peers in the list of buckets,\n         node_id : (str) the local dht node id\n    }", 
            "title": "routing_table_get"
        }, 
        {
            "location": "/cli/#settings_get", 
            "text": "Get daemon settings\n\nUsage:\n    settings_get\n\n\nOptions:\n          None\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings", 
            "title": "settings_get"
        }, 
        {
            "location": "/cli/#settings_set", 
            "text": "Set daemon settings\n\nUsage:\n    settings_set [--download_directory= download_directory ]\n                 [--data_rate= data_rate ]\n                 [--download_timeout= download_timeout ]\n                 [--peer_port= peer_port ]\n                 [--max_key_fee= max_key_fee ]\n                 [--disable_max_key_fee= disable_max_key_fee ]\n                 [--use_upnp= use_upnp ]\n                 [--run_reflector_server= run_reflector_server ]\n                 [--cache_time= cache_time ]\n                 [--reflect_uploads= reflect_uploads ]\n                 [--share_usage_data= share_usage_data ]\n                 [--peer_search_timeout= peer_search_timeout ]\n                 [--sd_download_timeout= sd_download_timeout ]\n                 [--auto_renew_claim_height_delta= auto_renew_claim_height_delta ]\n\n\nOptions:\n    --download_directory= download_directory                         :  (str)    path of download directory\n    --data_rate= data_rate                                           :  (float)  0.0001\n    --download_timeout= download_timeout                             :  (int)    180\n    --peer_port= peer_port                                           :  (int)    3333\n    --max_key_fee= max_key_fee                                       :  (dict)   maximum key fee for downloads,\n                                                                                 in the format:\n                                                                                 {\n                                                                                 'currency':  currency_symbol ,\n                                                                                 'amount':  amount \n                                                                                 }.\n                                                                                 In the CLI, it must be an escaped JSON string\n                                                                                 Supported currency symbols: LBC, USD, BTC\n    --disable_max_key_fee= disable_max_key_fee                       :  (bool)   False\n    --use_upnp= use_upnp                                             :  (bool)   True\n    --run_reflector_server= run_reflector_server                     :  (bool)   False\n    --cache_time= cache_time                                         :  (int)    150\n    --reflect_uploads= reflect_uploads                               :  (bool)   True\n    --share_usage_data= share_usage_data                             :  (bool)   True\n    --peer_search_timeout= peer_search_timeout                       :  (int)    3\n    --sd_download_timeout= sd_download_timeout                       :  (int)    3\n    --auto_renew_claim_height_delta= auto_renew_claim_height_delta   :  (int)    0\n                                                                                 claims set to expire within this many blocks will be\n                                                                                 automatically renewed after startup (if set to 0, renews\n                                                                                 will not be made automatically)\n\nReturns:\n    (dict) Updated dictionary of daemon settings", 
            "title": "settings_set"
        }, 
        {
            "location": "/cli/#status", 
            "text": "Get daemon status\n\nUsage:\n    status [--session_status]\n\n\nOptions:\n    --session_status  :  (bool)  include session status in results\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58,\n        'installation_id': installation id, base58,\n        'is_running': bool,\n        'is_first_run': bool,\n        'startup_status': {\n            'code': status code,\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code,\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n        'wallet_is_encrypted': bool,\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n    }", 
            "title": "status"
        }, 
        {
            "location": "/cli/#stream_availability", 
            "text": "Get stream availability for lbry uri\n\nUsage:\n    stream_availability ( uri  | --uri= uri )\n                        [ search_timeout  | --search_timeout= search_timeout ]\n                        [ blob_timeout  | --blob_timeout= blob_timeout ]\n\n\nOptions:\n    --uri= uri                         :  (str)  check availability for this uri\n    --search_timeout= search_timeout   :  (int)  how long to search for peers for the blob\n                                                 in the dht\n    --blob_timeout= blob_timeout       :  (int)  how long to try downloading from a peer\n\nReturns:\n    (dict) {\n        'is_available':  bool ,\n        'did_decode':  bool ,\n        'did_resolve':  bool ,\n        'is_stream':  bool ,\n        'num_blobs_in_stream':  int ,\n        'sd_hash':  str ,\n        'sd_blob_availability':  dict  see `blob_availability`,\n        'head_blob_hash':  str ,\n        'head_blob_availability':  dict  see `blob_availability`,\n        'use_upnp':  bool ,\n        'upnp_redirect_is_set':  bool ,\n        'error':  None  |  str  error message\n    }", 
            "title": "stream_availability"
        }, 
        {
            "location": "/cli/#stream_cost_estimate", 
            "text": "Get estimated cost for a lbry stream\n\nUsage:\n    stream_cost_estimate ( uri  | --uri= uri ) [ size  | --size= size ]\n\n\nOptions:\n    --uri= uri     :  (str)    uri to use\n    --size= size   :  (float)  stream size in bytes. if provided an sd blob won't be\n                               downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable", 
            "title": "stream_cost_estimate"
        }, 
        {
            "location": "/cli/#transaction_list", 
            "text": "List transactions belonging to wallet\n\nUsage:\n    transaction_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of transactions\n\n    {\n         claim_info : (list) claim info if in txn [{\n                                                 address : (str) address of claim,\n                                                 balance_delta : (float) bid amount,\n                                                 amount : (float) claim amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         abandon_info : (list) abandon info if in txn [{\n                                                 address : (str) address of abandoned claim,\n                                                 balance_delta : (float) returned amount,\n                                                 amount : (float) claim amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         confirmations : (int) number of confirmations for the txn,\n         date : (str) date and time of txn,\n         fee : (float) txn fee,\n         support_info : (list) support info if in txn [{\n                                                 address : (str) address of support,\n                                                 balance_delta : (float) support amount,\n                                                 amount : (float) support amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 is_tip : (bool),\n                                                 nout : (int) nout\n                                                }],\n         timestamp : (int) timestamp,\n         txid : (str) txn id,\n         update_info : (list) update info if in txn [{\n                                                 address : (str) address of claim,\n                                                 balance_delta : (float) credited/debited\n                                                 amount : (float) absolute amount,\n                                                 claim_id : (str) claim id,\n                                                 claim_name : (str) claim name,\n                                                 nout : (int) nout\n                                                }],\n         value : (float) value of txn\n    }", 
            "title": "transaction_list"
        }, 
        {
            "location": "/cli/#transaction_show", 
            "text": "Get a decoded transaction from a txid\n\nUsage:\n    transaction_show ( txid  | --txid= txid )\n\n\nOptions:\n    --txid= txid   :  (str)  txid of the transaction\n\nReturns:\n    (dict) JSON formatted transaction", 
            "title": "transaction_show"
        }, 
        {
            "location": "/cli/#utxo_list", 
            "text": "List unspent transaction outputs\n\nUsage:\n    utxo_list\n\n\nOptions:\n          None\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n             address : (str) the output address\n             amount : (float) unspent amount\n             height : (int) block height\n             is_claim : (bool) is the tx a claim\n             is_coinbase : (bool) is the tx a coinbase tx\n             is_support : (bool) is the tx a support\n             is_update : (bool) is the tx an update\n             nout : (int) nout of the output\n             txid : (str) txid of the output\n        },\n        ...\n    ]", 
            "title": "utxo_list"
        }, 
        {
            "location": "/cli/#version", 
            "text": "Get lbry version information\n\nUsage:\n    version\n\n\nOptions:\n          None\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g.  dev ,  rc ,  release ),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }", 
            "title": "version"
        }, 
        {
            "location": "/cli/#wallet_balance", 
            "text": "Return the balance of the wallet\n\nUsage:\n    wallet_balance [ address  | --address= address ] [--include_unconfirmed]\n\n\nOptions:\n    --address= address     :  (str)   If provided only the balance for this\n                                      address will be given\n    --include_unconfirmed  :  (bool)  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet", 
            "title": "wallet_balance"
        }, 
        {
            "location": "/cli/#wallet_decrypt", 
            "text": "Decrypt an encrypted wallet, this will remove the wallet password\n\nUsage:\n    wallet_decrypt\n\n\nOptions:\n          None\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false", 
            "title": "wallet_decrypt"
        }, 
        {
            "location": "/cli/#wallet_encrypt", 
            "text": "Encrypt a wallet with a password, if the wallet is already encrypted this will update\nthe password\n\nUsage:\n    wallet_encrypt ( new_password  | --new_password= new_password )\n\n\nOptions:\n    --new_password= new_password   :  (str)  password string to be used for encrypting wallet\n\nReturns:\n    (bool) true if wallet is decrypted, otherwise false", 
            "title": "wallet_encrypt"
        }, 
        {
            "location": "/cli/#wallet_is_address_mine", 
            "text": "Checks if an address is associated with the current wallet.\n\nUsage:\n    wallet_is_address_mine ( address  | --address= address )\n\n\nOptions:\n    --address= address   :  (str)  address to check\n\nReturns:\n    (bool) true, if address is associated with current wallet", 
            "title": "wallet_is_address_mine"
        }, 
        {
            "location": "/cli/#wallet_list", 
            "text": "List wallet addresses\n\nUsage:\n    wallet_list\n\n\nOptions:\n          None\n\nReturns:\n    List of wallet addresses", 
            "title": "wallet_list"
        }, 
        {
            "location": "/cli/#wallet_new_address", 
            "text": "Generate a new wallet address\n\nUsage:\n    wallet_new_address\n\n\nOptions:\n          None\n\nReturns:\n    (str) New wallet address in base58", 
            "title": "wallet_new_address"
        }, 
        {
            "location": "/cli/#wallet_prefill_addresses", 
            "text": "Create new addresses, each containing `amount` credits\n\nUsage:\n    wallet_prefill_addresses [--no_broadcast]\n                             ( num_addresses  | --num_addresses= num_addresses )\n                             ( amount  | --amount= amount )\n\n\nOptions:\n    --no_broadcast                   :  (bool)   whether to broadcast or not\n    --num_addresses= num_addresses   :  (int)    num of addresses to create\n    --amount= amount                 :  (float)  initial amount in each address\n\nReturns:\n    (dict) the resulting transaction", 
            "title": "wallet_prefill_addresses"
        }, 
        {
            "location": "/cli/#wallet_public_key", 
            "text": "Get public key from wallet address\n\nUsage:\n    wallet_public_key ( address  | --address= address )\n\n\nOptions:\n    --address= address   :  (str)  address for which to get the public key\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.", 
            "title": "wallet_public_key"
        }, 
        {
            "location": "/cli/#wallet_send", 
            "text": "Send credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nUsage:\n    wallet_send ( amount  | --amount= amount )\n                (( address  | --address= address ) | ( claim_id  | --claim_id= claim_id ))\n\n\nOptions:\n    --amount= amount       :  (float)  amount of credit to send\n    --address= address     :  (str)    address to send credits to\n    --claim_id= claim_id   :  (float)  claim_id of the claim to send to tip to\n\nReturns:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "wallet_send"
        }, 
        {
            "location": "/cli/#wallet_unlock", 
            "text": "Unlock an encrypted wallet\n\nUsage:\n    wallet_unlock ( password  | --password= password )\n\n\nOptions:\n    --password= password   :  (str)  password for unlocking wallet\n\nReturns:\n    (bool) true if wallet is unlocked, otherwise false", 
            "title": "wallet_unlock"
        }, 
        {
            "location": "/cli/#wallet_unused_address", 
            "text": "Return an address containing no balance, will create\na new address if there is none.\n\nUsage:\n    wallet_unused_address\n\n\nOptions:\n          None\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "wallet_unused_address"
        }
    ]
}
