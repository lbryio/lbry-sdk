[
    {
        "name": "account_add",
        "description": "Add a previously created account from a seed, private key or public key (read-only).\nSpecify --single_key for single address or vanity address accounts.",
        "arguments": [
            {
                "name": "account_name",
                "type": "str",
                "description": "name of the account to add",
                "is_required": true
            },
            {
                "name": "seed",
                "type": "str",
                "description": "seed to generate new account from",
                "is_required": false
            },
            {
                "name": "private_key",
                "type": "str",
                "description": "private key for new account",
                "is_required": false
            },
            {
                "name": "public_key",
                "type": "str",
                "description": "public key for new account",
                "is_required": false
            },
            {
                "name": "single_key",
                "type": "bool",
                "description": "create single key account, default is multi-key",
                "is_required": false
            }
        ],
        "returns": "(map) added account details",
        "examples": [
            {
                "title": "performing account_add operation",
                "curl": "curl -d'{\"method\": \"account_add\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_add --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_add\"}).json()",
                "output": "(map) added account details"
            }
        ]
    },
    {
        "name": "account_balance",
        "description": "Return the balance of an account",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "If provided only the balance for this account will be given. Otherwise default account.",
                "is_required": false
            },
            {
                "name": "confirmations",
                "type": "int",
                "description": "Only include transactions with this many confirmed blocks.",
                "is_required": false
            }
        ],
        "returns": "(decimal) amount of lbry credits in wallet",
        "examples": [
            {
                "title": "performing account_balance operation",
                "curl": "curl -d'{\"method\": \"account_balance\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_balance --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_balance\"}).json()",
                "output": "(decimal) amount of lbry credits in wallet"
            }
        ]
    },
    {
        "name": "account_create",
        "description": "Create a new account. Specify --single_key if you want to use\nthe same address for all transactions (not recommended).",
        "arguments": [
            {
                "name": "account_name",
                "type": "str",
                "description": "name of the account to create",
                "is_required": true
            },
            {
                "name": "single_key",
                "type": "bool",
                "description": "create single key account, default is multi-key",
                "is_required": false
            }
        ],
        "returns": "(map) new account details",
        "examples": [
            {
                "title": "performing account_create operation",
                "curl": "curl -d'{\"method\": \"account_create\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_create --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_create\"}).json()",
                "output": "(map) new account details"
            }
        ]
    },
    {
        "name": "account_decrypt",
        "description": "Decrypt an encrypted account, this will remove the wallet password. The account must be unlocked to decrypt it",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id for the account to decrypt",
                "is_required": false
            }
        ],
        "returns": "(bool) true if wallet is decrypted, otherwise false",
        "examples": [
            {
                "title": "performing account_decrypt operation",
                "curl": "curl -d'{\"method\": \"account_decrypt\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_decrypt --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_decrypt\"}).json()",
                "output": "(bool) true if wallet is decrypted, otherwise false"
            }
        ]
    },
    {
        "name": "account_encrypt",
        "description": "Encrypt an unencrypted account with a password",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id for the account to encrypt",
                "is_required": false
            }
        ],
        "returns": "(bool) true if wallet is decrypted, otherwise false",
        "examples": [
            {
                "title": "performing account_encrypt operation",
                "curl": "curl -d'{\"method\": \"account_encrypt\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_encrypt --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_encrypt\"}).json()",
                "output": "(bool) true if wallet is decrypted, otherwise false"
            }
        ]
    },
    {
        "name": "account_fund",
        "description": "Transfer some amount (or --everything) to an account from another\naccount (can be the same account). Amounts are interpreted as LBC.\nYou can also spread the transfer across a number of --outputs (cannot\nbe used together with --everything).",
        "arguments": [
            {
                "name": "to_account",
                "type": "str",
                "description": "send to this account",
                "is_required": false
            },
            {
                "name": "from_account",
                "type": "str",
                "description": "spend from this account",
                "is_required": false
            },
            {
                "name": "amount",
                "type": "str",
                "description": "the amount to transfer lbc",
                "is_required": true
            },
            {
                "name": "everything",
                "type": "bool",
                "description": "transfer everything (excluding claims), default: false.",
                "is_required": false
            },
            {
                "name": "outputs",
                "type": "int",
                "description": "split payment across many outputs, default: 1.",
                "is_required": false
            },
            {
                "name": "broadcast",
                "type": "bool",
                "description": "actually broadcast the transaction, default: false.",
                "is_required": false
            }
        ],
        "returns": "(map) transaction performing requested action",
        "examples": [
            {
                "title": "performing account_fund operation",
                "curl": "curl -d'{\"method\": \"account_fund\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_fund --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_fund\"}).json()",
                "output": "(map) transaction performing requested action"
            }
        ]
    },
    {
        "name": "account_list",
        "description": "List details of all of the accounts or a specific account.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "If provided only the balance for this account will be given",
                "is_required": false
            },
            {
                "name": "confirmations",
                "type": "int",
                "description": "required confirmations (default: 0)",
                "is_required": false
            },
            {
                "name": "include_claims",
                "type": "bool",
                "description": "include claims, requires than a LBC account is specified (default: false)",
                "is_required": false
            },
            {
                "name": "show_seed",
                "type": "bool",
                "description": "show the seed for the account",
                "is_required": false
            }
        ],
        "returns": "(map) balance of account(s)",
        "examples": [
            {
                "title": "performing account_list operation",
                "curl": "curl -d'{\"method\": \"account_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_list\"}).json()",
                "output": "(map) balance of account(s)"
            }
        ]
    },
    {
        "name": "account_lock",
        "description": "Lock an unlocked account",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id for the account to lock",
                "is_required": false
            }
        ],
        "returns": "(bool) true if account is locked, otherwise false",
        "examples": [
            {
                "title": "performing account_lock operation",
                "curl": "curl -d'{\"method\": \"account_lock\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_lock --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_lock\"}).json()",
                "output": "(bool) true if account is locked, otherwise false"
            }
        ]
    },
    {
        "name": "account_max_address_gap",
        "description": "Finds ranges of consecutive addresses that are unused and returns the length\nof the longest such range: for change and receiving address chains. This is\nuseful to figure out ideal values to set for 'receiving_gap' and 'change_gap'\naccount settings.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "account for which to get max gaps",
                "is_required": true
            }
        ],
        "returns": "(map) maximum gap for change and receiving addresses",
        "examples": [
            {
                "title": "performing account_max_address_gap operation",
                "curl": "curl -d'{\"method\": \"account_max_address_gap\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_max_address_gap --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_max_address_gap\"}).json()",
                "output": "(map) maximum gap for change and receiving addresses"
            }
        ]
    },
    {
        "name": "account_remove",
        "description": "Remove an existing account.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to remove",
                "is_required": true
            }
        ],
        "returns": "(map) details of removed account",
        "examples": [
            {
                "title": "performing account_remove operation",
                "curl": "curl -d'{\"method\": \"account_remove\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_remove --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_remove\"}).json()",
                "output": "(map) details of removed account"
            }
        ]
    },
    {
        "name": "account_send",
        "description": "Send the same number of credits to multiple addresses.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "account to fund the transaction",
                "is_required": false
            },
            {
                "name": "broadcast",
                "type": "bool",
                "description": "actually broadcast the transaction, default: false.",
                "is_required": false
            }
        ],
        "returns": "",
        "examples": [
            {
                "title": "performing account_send operation",
                "curl": "curl -d'{\"method\": \"account_send\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_send --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_send\"}).json()",
                "output": ""
            }
        ]
    },
    {
        "name": "account_set",
        "description": "Change various settings on an account.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to change",
                "is_required": true
            },
            {
                "name": "default",
                "type": "bool",
                "description": "make this account the default",
                "is_required": false
            },
            {
                "name": "new_name",
                "type": "str",
                "description": "new name for the account",
                "is_required": false
            },
            {
                "name": "receiving_gap",
                "type": "int",
                "description": "set the gap for receiving addresses",
                "is_required": false
            },
            {
                "name": "receiving_max_uses",
                "type": "int",
                "description": "set the maximum number of times to use a receiving address",
                "is_required": false
            },
            {
                "name": "change_gap",
                "type": "int",
                "description": "set the gap for change addresses",
                "is_required": false
            },
            {
                "name": "change_max_uses",
                "type": "int",
                "description": "set the maximum number of times to use a change address",
                "is_required": false
            }
        ],
        "returns": "(map) updated account details",
        "examples": [
            {
                "title": "performing account_set operation",
                "curl": "curl -d'{\"method\": \"account_set\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_set --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_set\"}).json()",
                "output": "(map) updated account details"
            }
        ]
    },
    {
        "name": "account_unlock",
        "description": "Unlock an encrypted account",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id for the account to unlock",
                "is_required": false
            }
        ],
        "returns": "(bool) true if account is unlocked, otherwise false",
        "examples": [
            {
                "title": "performing account_unlock operation",
                "curl": "curl -d'{\"method\": \"account_unlock\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  account_unlock --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"account_unlock\"}).json()",
                "output": "(bool) true if account is unlocked, otherwise false"
            }
        ]
    },
    {
        "name": "address_is_mine",
        "description": "Checks if an address is associated with the current wallet.",
        "arguments": [
            {
                "name": "address",
                "type": "str",
                "description": "address to check",
                "is_required": true
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            }
        ],
        "returns": "(bool) true, if address is associated with current wallet",
        "examples": [
            {
                "title": "performing address_is_mine operation",
                "curl": "curl -d'{\"method\": \"address_is_mine\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  address_is_mine --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"address_is_mine\"}).json()",
                "output": "(bool) true, if address is associated with current wallet"
            }
        ]
    },
    {
        "name": "address_list",
        "description": "List account addresses",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page to return during paginating",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of items on page during pagination",
                "is_required": false
            }
        ],
        "returns": "List of wallet addresses",
        "examples": [
            {
                "title": "performing address_list operation",
                "curl": "curl -d'{\"method\": \"address_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  address_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"address_list\"}).json()",
                "output": "List of wallet addresses"
            }
        ]
    },
    {
        "name": "address_unused",
        "description": "Return an address containing no balance, will create\na new address if there is none.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            }
        ],
        "returns": "(str) Unused wallet address in base58",
        "examples": [
            {
                "title": "performing address_unused operation",
                "curl": "curl -d'{\"method\": \"address_unused\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  address_unused --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"address_unused\"}).json()",
                "output": "(str) Unused wallet address in base58"
            }
        ]
    },
    {
        "name": "blob_announce",
        "description": "Announce blobs to the DHT",
        "arguments": [
            {
                "name": "blob_hash",
                "type": "str",
                "description": "announce a blob, specified by blob_hash",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "announce all blobs associated with stream_hash",
                "is_required": false
            },
            {
                "name": "sd_hash",
                "type": "str",
                "description": "announce all blobs associated with sd_hash and the sd_hash itself",
                "is_required": false
            }
        ],
        "returns": "(bool) true if successful",
        "examples": [
            {
                "title": "performing blob_announce operation",
                "curl": "curl -d'{\"method\": \"blob_announce\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_announce --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_announce\"}).json()",
                "output": "(bool) true if successful"
            }
        ]
    },
    {
        "name": "blob_availability",
        "description": "Get blob availability",
        "arguments": [
            {
                "name": "blob_hash",
                "type": "str",
                "description": "check availability for this blob hash",
                "is_required": true
            },
            {
                "name": "search_timeout",
                "type": "int",
                "description": "how long to search for peers for the blob in the dht",
                "is_required": false
            },
            {
                "name": "blob_timeout",
                "type": "int",
                "description": "how long to try downloading from a peer",
                "is_required": false
            }
        ],
        "returns": "(dict) {\n        \"is_available\": <bool, true if blob is available from a peer from peer list>\n        \"reachable_peers\": [\"<ip>:<port>\"],\n        \"unreachable_peers\": [\"<ip>:<port>\"]\n    }",
        "examples": [
            {
                "title": "performing blob_availability operation",
                "curl": "curl -d'{\"method\": \"blob_availability\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_availability --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_availability\"}).json()",
                "output": "(dict) {\n        \"is_available\": <bool, true if blob is available from a peer from peer list>\n        \"reachable_peers\": [\"<ip>:<port>\"],\n        \"unreachable_peers\": [\"<ip>:<port>\"]\n    }"
            }
        ]
    },
    {
        "name": "blob_delete",
        "description": "Delete a blob",
        "arguments": [
            {
                "name": "blob_hash",
                "type": "str",
                "description": "blob hash of the blob to delete",
                "is_required": true
            }
        ],
        "returns": "(str) Success/fail message",
        "examples": [
            {
                "title": "performing blob_delete operation",
                "curl": "curl -d'{\"method\": \"blob_delete\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_delete --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_delete\"}).json()",
                "output": "(str) Success/fail message"
            }
        ]
    },
    {
        "name": "blob_get",
        "description": "Download and return a blob",
        "arguments": [
            {
                "name": "blob_hash",
                "type": "str",
                "description": "blob hash of the blob to get",
                "is_required": true
            },
            {
                "name": "timeout",
                "type": "int",
                "description": "timeout in number of seconds",
                "is_required": false
            },
            {
                "name": "encoding",
                "type": "str",
                "description": "by default no attempt at decoding is made, can be set to one of the following decoders: 'json'",
                "is_required": false
            },
            {
                "name": "payment_rate_manager",
                "type": "str",
                "description": "if not given the default payment rate manager will be used. supported alternative rate managers: 'only-free'",
                "is_required": false
            }
        ],
        "returns": "(str) Success/Fail message or (dict) decoded data",
        "examples": [
            {
                "title": "performing blob_get operation",
                "curl": "curl -d'{\"method\": \"blob_get\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_get --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_get\"}).json()",
                "output": "(str) Success/Fail message or (dict) decoded data"
            }
        ]
    },
    {
        "name": "blob_list",
        "description": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager",
        "arguments": [
            {
                "name": "needed",
                "type": "bool",
                "description": "only return needed blobs",
                "is_required": false
            },
            {
                "name": "finished",
                "type": "bool",
                "description": "only return finished blobs",
                "is_required": false
            },
            {
                "name": "uri",
                "type": "str",
                "description": "filter blobs by stream in a uri",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "filter blobs by stream hash",
                "is_required": false
            },
            {
                "name": "sd_hash",
                "type": "str",
                "description": "filter blobs by sd hash",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "results page size",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page of results to return",
                "is_required": false
            }
        ],
        "returns": "(list) List of blob hashes",
        "examples": [
            {
                "title": "performing blob_list operation",
                "curl": "curl -d'{\"method\": \"blob_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_list\"}).json()",
                "output": "(list) List of blob hashes"
            }
        ]
    },
    {
        "name": "blob_reflect",
        "description": "Reflects specified blobs",
        "arguments": [
            {
                "name": "reflector_server",
                "type": "str",
                "description": "reflector address",
                "is_required": false
            }
        ],
        "returns": "(list) reflected blob hashes",
        "examples": [
            {
                "title": "performing blob_reflect operation",
                "curl": "curl -d'{\"method\": \"blob_reflect\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_reflect --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_reflect\"}).json()",
                "output": "(list) reflected blob hashes"
            }
        ]
    },
    {
        "name": "blob_reflect_all",
        "description": "Reflects all saved blobs",
        "arguments": [],
        "returns": "(bool) true if successful",
        "examples": [
            {
                "title": "performing blob_reflect_all operation",
                "curl": "curl -d'{\"method\": \"blob_reflect_all\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  blob_reflect_all --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"blob_reflect_all\"}).json()",
                "output": "(bool) true if successful"
            }
        ]
    },
    {
        "name": "block_show",
        "description": "Get contents of a block",
        "arguments": [
            {
                "name": "blockhash",
                "type": "str",
                "description": "hash of the block to look up",
                "is_required": true
            },
            {
                "name": "height",
                "type": "int",
                "description": "height of the block to look up",
                "is_required": true
            }
        ],
        "returns": "(dict) Requested block",
        "examples": [
            {
                "title": "performing block_show operation",
                "curl": "curl -d'{\"method\": \"block_show\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  block_show --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"block_show\"}).json()",
                "output": "(dict) Requested block"
            }
        ]
    },
    {
        "name": "channel_export",
        "description": "Export serialized channel signing information for a given certificate claim id",
        "arguments": [
            {
                "name": "claim_id",
                "type": "str",
                "description": "Claim ID to export information about",
                "is_required": true
            }
        ],
        "returns": "(str) Serialized certificate information",
        "examples": [
            {
                "title": "performing channel_export operation",
                "curl": "curl -d'{\"method\": \"channel_export\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  channel_export --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"channel_export\"}).json()",
                "output": "(str) Serialized certificate information"
            }
        ]
    },
    {
        "name": "channel_import",
        "description": "Import serialized channel signing information (to allow signing new claims to the channel)",
        "arguments": [
            {
                "name": "serialized_certificate_info",
                "type": "str",
                "description": "certificate info",
                "is_required": true
            }
        ],
        "returns": "(dict) Result dictionary",
        "examples": [
            {
                "title": "performing channel_import operation",
                "curl": "curl -d'{\"method\": \"channel_import\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  channel_import --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"channel_import\"}).json()",
                "output": "(dict) Result dictionary"
            }
        ]
    },
    {
        "name": "channel_list",
        "description": "Get certificate claim infos for channels that can be published to",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page to return during paginating",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of items on page during pagination",
                "is_required": false
            }
        ],
        "returns": "(list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.",
        "examples": [
            {
                "title": "performing channel_list operation",
                "curl": "curl -d'{\"method\": \"channel_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  channel_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"channel_list\"}).json()",
                "output": "(list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet."
            }
        ]
    },
    {
        "name": "channel_new",
        "description": "Generate a publisher key and create a new '@' prefixed certificate claim",
        "arguments": [
            {
                "name": "channel_name",
                "type": "str",
                "description": "name of the channel prefixed with '@'",
                "is_required": true
            },
            {
                "name": "amount",
                "type": "decimal",
                "description": "bid amount on the channel",
                "is_required": true
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to store channel",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }",
        "examples": [
            {
                "title": "performing channel_new operation",
                "curl": "curl -d'{\"method\": \"channel_new\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  channel_new --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"channel_new\"}).json()",
                "output": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }"
            }
        ]
    },
    {
        "name": "claim_abandon",
        "description": "Abandon a name and reclaim credits from the claim",
        "arguments": [
            {
                "name": "claim_id",
                "type": "str",
                "description": "claim_id of the claim to abandon",
                "is_required": false
            },
            {
                "name": "txid",
                "type": "str",
                "description": "txid of the claim to abandon",
                "is_required": false
            },
            {
                "name": "nout",
                "type": "int",
                "description": "nout of the claim to abandon",
                "is_required": false
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            },
            {
                "name": "blocking",
                "type": "bool",
                "description": "wait until abandon is in mempool",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing result of the claim\n    {\n        success: (bool) True if txn is successful\n        txid : (str) txid of resulting transaction\n    }",
        "examples": [
            {
                "title": "performing claim_abandon operation",
                "curl": "curl -d'{\"method\": \"claim_abandon\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_abandon --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_abandon\"}).json()",
                "output": "(dict) Dictionary containing result of the claim\n    {\n        success: (bool) True if txn is successful\n        txid : (str) txid of resulting transaction\n    }"
            }
        ]
    },
    {
        "name": "claim_list",
        "description": "List current claims and information about them for a given name",
        "arguments": [
            {
                "name": "name",
                "type": "str",
                "description": "name of the claim to list info about",
                "is_required": true
            }
        ],
        "returns": "(dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }",
        "examples": [
            {
                "title": "performing claim_list operation",
                "curl": "curl -d'{\"method\": \"claim_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_list\"}).json()",
                "output": "(dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }"
            }
        ]
    },
    {
        "name": "claim_list_by_channel",
        "description": "Get paginated claims in a channel specified by a channel uri",
        "arguments": [
            {
                "name": "uri",
                "type": "str",
                "description": "uri of the channel",
                "is_required": true
            },
            {
                "name": "uris",
                "type": "list",
                "description": "uris of the channel",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "which page of results to return where page 1 is the first page, defaults to no pages",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of results in a page, default of 10",
                "is_required": false
            }
        ],
        "returns": "{\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }",
        "examples": [
            {
                "title": "performing claim_list_by_channel operation",
                "curl": "curl -d'{\"method\": \"claim_list_by_channel\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_list_by_channel --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_list_by_channel\"}).json()",
                "output": "{\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }"
            }
        ]
    },
    {
        "name": "claim_list_mine",
        "description": "List my name claims",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to query",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page to return during paginating",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of items on page during pagination",
                "is_required": false
            }
        ],
        "returns": "(list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \"claim\", \"update\" , or \"support\"\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]",
        "examples": [
            {
                "title": "performing claim_list_mine operation",
                "curl": "curl -d'{\"method\": \"claim_list_mine\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_list_mine --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_list_mine\"}).json()",
                "output": "(list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \"claim\", \"update\" , or \"support\"\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'permanent_url': (str) permanent url of the claim,\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]"
            }
        ]
    },
    {
        "name": "claim_new_support",
        "description": "Support a name claim",
        "arguments": [
            {
                "name": "name",
                "type": "str",
                "description": "name of the claim to support",
                "is_required": true
            },
            {
                "name": "claim_id",
                "type": "str",
                "description": "claim_id of the claim to support",
                "is_required": true
            },
            {
                "name": "amount",
                "type": "decimal",
                "description": "amount of support",
                "is_required": true
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }",
        "examples": [
            {
                "title": "performing claim_new_support operation",
                "curl": "curl -d'{\"method\": \"claim_new_support\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_new_support --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_new_support\"}).json()",
                "output": "(dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }"
            }
        ]
    },
    {
        "name": "claim_send_to_address",
        "description": "Send a name claim to an address",
        "arguments": [
            {
                "name": "claim_id",
                "type": "str",
                "description": "claim_id to send",
                "is_required": true
            },
            {
                "name": "address",
                "type": "str",
                "description": "address to send the claim to",
                "is_required": true
            },
            {
                "name": "amount",
                "type": "int",
                "description": "Amount of credits to claim name for, defaults to the current amount on the claim",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }",
        "examples": [
            {
                "title": "performing claim_send_to_address operation",
                "curl": "curl -d'{\"method\": \"claim_send_to_address\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_send_to_address --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_send_to_address\"}).json()",
                "output": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }"
            }
        ]
    },
    {
        "name": "claim_show",
        "description": "Resolve claim info from txid/nout or with claim ID",
        "arguments": [
            {
                "name": "txid",
                "type": "str",
                "description": "look for claim with this txid, nout must also be specified",
                "is_required": false
            },
            {
                "name": "nout",
                "type": "int",
                "description": "look for claim with this nout, txid must also be specified",
                "is_required": false
            },
            {
                "name": "claim_id",
                "type": "str",
                "description": "look for claim with this claim id",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }",
        "examples": [
            {
                "title": "performing claim_show operation",
                "curl": "curl -d'{\"method\": \"claim_show\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_show --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_show\"}).json()",
                "output": "(dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }"
            }
        ]
    },
    {
        "name": "claim_tip",
        "description": "Tip the owner of the claim",
        "arguments": [
            {
                "name": "claim_id",
                "type": "str",
                "description": "claim_id of the claim to support",
                "is_required": true
            },
            {
                "name": "amount",
                "type": "decimal",
                "description": "amount of support",
                "is_required": true
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to use",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }",
        "examples": [
            {
                "title": "performing claim_tip operation",
                "curl": "curl -d'{\"method\": \"claim_tip\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  claim_tip --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"claim_tip\"}).json()",
                "output": "(dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }"
            }
        ]
    },
    {
        "name": "commands",
        "description": "Return a list of available commands",
        "arguments": [],
        "returns": "(list) list of available commands",
        "examples": [
            {
                "title": "performing commands operation",
                "curl": "curl -d'{\"method\": \"commands\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  commands --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"commands\"}).json()",
                "output": "(list) list of available commands"
            }
        ]
    },
    {
        "name": "file_delete",
        "description": "Delete a LBRY file",
        "arguments": [
            {
                "name": "delete_from_download_dir",
                "type": "bool",
                "description": "delete file from download directory, instead of just deleting blobs",
                "is_required": false
            },
            {
                "name": "delete_all",
                "type": "bool",
                "description": "if there are multiple matching files, allow the deletion of multiple files. Otherwise do not delete anything.",
                "is_required": false
            },
            {
                "name": "sd_hash",
                "type": "str",
                "description": "delete by file sd hash",
                "is_required": false
            },
            {
                "name": "file_name",
                "type": "str",
                "description": "delete by file name in downloads folder",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "delete by file stream hash",
                "is_required": false
            },
            {
                "name": "rowid",
                "type": "int",
                "description": "delete by file row id",
                "is_required": false
            },
            {
                "name": "claim_id",
                "type": "str",
                "description": "delete by file claim id",
                "is_required": false
            },
            {
                "name": "txid",
                "type": "str",
                "description": "delete by file claim txid",
                "is_required": false
            },
            {
                "name": "nout",
                "type": "int",
                "description": "delete by file claim nout",
                "is_required": false
            },
            {
                "name": "claim_name",
                "type": "str",
                "description": "delete by file claim name",
                "is_required": false
            },
            {
                "name": "channel_claim_id",
                "type": "str",
                "description": "delete by file channel claim id",
                "is_required": false
            },
            {
                "name": "channel_name",
                "type": "str",
                "description": "delete by file channel claim name",
                "is_required": false
            }
        ],
        "returns": "(bool) true if deletion was successful",
        "examples": [
            {
                "title": "performing file_delete operation",
                "curl": "curl -d'{\"method\": \"file_delete\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  file_delete --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"file_delete\"}).json()",
                "output": "(bool) true if deletion was successful"
            }
        ]
    },
    {
        "name": "file_list",
        "description": "List files limited by optional filters",
        "arguments": [
            {
                "name": "sd_hash",
                "type": "str",
                "description": "get file with matching sd hash",
                "is_required": false
            },
            {
                "name": "file_name",
                "type": "str",
                "description": "get file with matching file name in the downloads folder",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "get file with matching stream hash",
                "is_required": false
            },
            {
                "name": "rowid",
                "type": "int",
                "description": "get file with matching row id",
                "is_required": false
            },
            {
                "name": "claim_id",
                "type": "str",
                "description": "get file with matching claim id",
                "is_required": false
            },
            {
                "name": "outpoint",
                "type": "str",
                "description": "get file with matching claim outpoint",
                "is_required": false
            },
            {
                "name": "txid",
                "type": "str",
                "description": "get file with matching claim txid",
                "is_required": false
            },
            {
                "name": "nout",
                "type": "int",
                "description": "get file with matching claim nout",
                "is_required": false
            },
            {
                "name": "channel_claim_id",
                "type": "str",
                "description": "get file with matching channel claim id",
                "is_required": false
            },
            {
                "name": "channel_name",
                "type": "str",
                "description": "get file with matching channel name",
                "is_required": false
            },
            {
                "name": "claim_name",
                "type": "str",
                "description": "get file with matching claim name",
                "is_required": false
            },
            {
                "name": "sort",
                "type": "str",
                "description": "sort by any property, like 'file_name' or 'metadata.author'; to specify direction append ',asc' or ',desc'",
                "is_required": false
            }
        ],
        "returns": "(list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) number of fully downloaded blobs,\n            'blobs_in_stream': (int) total blobs on stream,\n            'status': (str) downloader status\n            'claim_id': (str) None if claim is not found else the claim id,\n            'outpoint': (str) None if claim is not found else the tx and output,\n            'txid': (str) None if claim is not found else the transaction id,\n            'nout': (int) None if claim is not found else the transaction output index,\n            'metadata': (dict) None if claim is not found else the claim metadata,\n            'channel_claim_id': (str) None if claim is not found or not signed,\n            'channel_name': (str) None if claim is not found or not signed,\n            'claim_name': (str) None if claim is not found else the claim name\n        },\n    ]",
        "examples": [
            {
                "title": "performing file_list operation",
                "curl": "curl -d'{\"method\": \"file_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  file_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"file_list\"}).json()",
                "output": "(list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes,\n            'written_bytes': (int) written size in bytes,\n            'blobs_completed': (int) number of fully downloaded blobs,\n            'blobs_in_stream': (int) total blobs on stream,\n            'status': (str) downloader status\n            'claim_id': (str) None if claim is not found else the claim id,\n            'outpoint': (str) None if claim is not found else the tx and output,\n            'txid': (str) None if claim is not found else the transaction id,\n            'nout': (int) None if claim is not found else the transaction output index,\n            'metadata': (dict) None if claim is not found else the claim metadata,\n            'channel_claim_id': (str) None if claim is not found or not signed,\n            'channel_name': (str) None if claim is not found or not signed,\n            'claim_name': (str) None if claim is not found else the claim name\n        },\n    ]"
            }
        ]
    },
    {
        "name": "file_reflect",
        "description": "Reflect all the blobs in a file matching the filter criteria",
        "arguments": [
            {
                "name": "sd_hash",
                "type": "str",
                "description": "get file with matching sd hash",
                "is_required": false
            },
            {
                "name": "file_name",
                "type": "str",
                "description": "get file with matching file name in the downloads folder",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "get file with matching stream hash",
                "is_required": false
            },
            {
                "name": "rowid",
                "type": "int",
                "description": "get file with matching row id",
                "is_required": false
            },
            {
                "name": "reflector",
                "type": "str",
                "description": "reflector server, ip address or url by default choose a server from the config",
                "is_required": false
            }
        ],
        "returns": "(list) list of blobs reflected",
        "examples": [
            {
                "title": "performing file_reflect operation",
                "curl": "curl -d'{\"method\": \"file_reflect\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  file_reflect --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"file_reflect\"}).json()",
                "output": "(list) list of blobs reflected"
            }
        ]
    },
    {
        "name": "file_set_status",
        "description": "Start or stop downloading a file",
        "arguments": [
            {
                "name": "status",
                "type": "str",
                "description": "one of \"start\" or \"stop\"",
                "is_required": true
            },
            {
                "name": "sd_hash",
                "type": "str",
                "description": "set status of file with matching sd hash",
                "is_required": false
            },
            {
                "name": "file_name",
                "type": "str",
                "description": "set status of file with matching file name in the downloads folder",
                "is_required": false
            },
            {
                "name": "stream_hash",
                "type": "str",
                "description": "set status of file with matching stream hash",
                "is_required": false
            },
            {
                "name": "rowid",
                "type": "int",
                "description": "set status of file with matching row id",
                "is_required": false
            }
        ],
        "returns": "(str) Confirmation message",
        "examples": [
            {
                "title": "performing file_set_status operation",
                "curl": "curl -d'{\"method\": \"file_set_status\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  file_set_status --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"file_set_status\"}).json()",
                "output": "(str) Confirmation message"
            }
        ]
    },
    {
        "name": "get",
        "description": "Download stream from a LBRY name.",
        "arguments": [
            {
                "name": "uri",
                "type": "str",
                "description": "uri of the content to download",
                "is_required": false
            },
            {
                "name": "file_name",
                "type": "str",
                "description": "specified name for the downloaded file",
                "is_required": false
            },
            {
                "name": "timeout",
                "type": "int",
                "description": "download timeout in number of seconds",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) number of fully downloaded blobs,\n        'blobs_in_stream': (int) total blobs on stream,\n        'status': (str) downloader status,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }",
        "examples": [
            {
                "title": "performing get operation",
                "curl": "curl -d'{\"method\": \"get\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  get --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"get\"}).json()",
                "output": "(dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name ,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes,\n        'written_bytes': (int) written size in bytes,\n        'blobs_completed': (int) number of fully downloaded blobs,\n        'blobs_in_stream': (int) total blobs on stream,\n        'status': (str) downloader status,\n        'claim_id': (str) claim id,\n        'outpoint': (str) claim outpoint string,\n        'txid': (str) claim txid,\n        'nout': (int) claim nout,\n        'metadata': (dict) claim metadata,\n        'channel_claim_id': (str) None if claim is not signed\n        'channel_name': (str) None if claim is not signed\n        'claim_name': (str) claim name\n    }"
            }
        ]
    },
    {
        "name": "help",
        "description": "Return a useful message for an API command",
        "arguments": [
            {
                "name": "command",
                "type": "str",
                "description": "command to retrieve documentation for",
                "is_required": false
            }
        ],
        "returns": "(str) Help message",
        "examples": [
            {
                "title": "performing help operation",
                "curl": "curl -d'{\"method\": \"help\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  help --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"help\"}).json()",
                "output": "(str) Help message"
            }
        ]
    },
    {
        "name": "peer_list",
        "description": "Get peers for blob hash",
        "arguments": [
            {
                "name": "blob_hash",
                "type": "str",
                "description": "find available peers for this blob hash",
                "is_required": true
            },
            {
                "name": "timeout",
                "type": "int",
                "description": "peer search timeout in seconds",
                "is_required": false
            }
        ],
        "returns": "(list) List of contact dictionaries {'host': <peer ip>, 'port': <peer port>, 'node_id': <peer node id>}",
        "examples": [
            {
                "title": "performing peer_list operation",
                "curl": "curl -d'{\"method\": \"peer_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  peer_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"peer_list\"}).json()",
                "output": "(list) List of contact dictionaries {'host': <peer ip>, 'port': <peer port>, 'node_id': <peer node id>}"
            }
        ]
    },
    {
        "name": "peer_ping",
        "description": "Send a kademlia ping to the specified peer. If address and port are provided the peer is directly pinged,\nif not provided the peer is located first.",
        "arguments": [
            {
                "name": "address",
                "type": "str",
                "description": "ip address of the peer",
                "is_required": false
            },
            {
                "name": "port",
                "type": "int",
                "description": "udp port of the peer",
                "is_required": false
            }
        ],
        "returns": "(str) pong, or {'error': <error message>} if an error is encountered",
        "examples": [
            {
                "title": "performing peer_ping operation",
                "curl": "curl -d'{\"method\": \"peer_ping\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  peer_ping --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"peer_ping\"}).json()",
                "output": "(str) pong, or {'error': <error message>} if an error is encountered"
            }
        ]
    },
    {
        "name": "publish",
        "description": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.",
        "arguments": [
            {
                "name": "name",
                "type": "str",
                "description": "name of the content (can only consist of a-z A-Z 0-9 and -(dash))",
                "is_required": true
            },
            {
                "name": "bid",
                "type": "decimal",
                "description": "amount to back the claim",
                "is_required": true
            },
            {
                "name": "metadata",
                "type": "dict",
                "description": "ClaimDict to associate with the claim.",
                "is_required": false
            },
            {
                "name": "file_path",
                "type": "str",
                "description": "path to file to be associated with name. If provided, a lbry stream of this file will be used in 'sources'. If no path is given but a sources dict is provided, it will be used. If neither are provided, an error is raised.",
                "is_required": false
            },
            {
                "name": "fee",
                "type": "dict",
                "description": "Dictionary representing key fee to download content: { 'currency': currency_symbol, 'amount': decimal, 'address': str, optional } supported currencies: LBC, USD, BTC If an address is not provided a new one will be automatically generated. Default fee is zero.",
                "is_required": false
            },
            {
                "name": "title",
                "type": "str",
                "description": "title of the publication",
                "is_required": false
            },
            {
                "name": "description",
                "type": "str",
                "description": "description of the publication",
                "is_required": false
            },
            {
                "name": "author",
                "type": "str",
                "description": "author of the publication. The usage for this field is not the same as for channels. The author field is used to credit an author who is not the publisher and is not represented by the channel. For example, a pdf file of 'The Odyssey' has an author of 'Homer' but may by published to a channel such as '@classics', or to no channel at all",
                "is_required": false
            },
            {
                "name": "language",
                "type": "str",
                "description": "language of the publication",
                "is_required": false
            },
            {
                "name": "license",
                "type": "str",
                "description": "publication license",
                "is_required": false
            },
            {
                "name": "license_url",
                "type": "str",
                "description": "publication license url",
                "is_required": false
            },
            {
                "name": "thumbnail",
                "type": "str",
                "description": "thumbnail url",
                "is_required": false
            },
            {
                "name": "preview",
                "type": "str",
                "description": "preview url",
                "is_required": false
            },
            {
                "name": "nsfw",
                "type": "bool",
                "description": "whether the content is nsfw",
                "is_required": false
            },
            {
                "name": "sources",
                "type": "str",
                "description": "{'lbry_sd_hash': sd_hash} specifies sd hash of file",
                "is_required": false
            },
            {
                "name": "channel_name",
                "type": "str",
                "description": "name of the publisher channel name in the wallet",
                "is_required": false
            },
            {
                "name": "channel_id",
                "type": "str",
                "description": "claim id of the publisher channel, does not check for channel claim being in the wallet. This allows publishing to a channel where only the certificate private key is in the wallet.",
                "is_required": false
            },
            {
                "name": "channel_account_id",
                "type": "str",
                "description": "one or more account ids for accounts to look in for channel certificates, defaults to all accounts.",
                "is_required": false
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "account to use for funding the transaction",
                "is_required": false
            },
            {
                "name": "claim_address",
                "type": "str",
                "description": "address where the claim is sent to, if not specified new address will automatically be created",
                "is_required": false
            }
        ],
        "returns": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }",
        "examples": [
            {
                "title": "performing publish operation",
                "curl": "curl -d'{\"method\": \"publish\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  publish --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"publish\"}).json()",
                "output": "(dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (decimal) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }"
            }
        ]
    },
    {
        "name": "report_bug",
        "description": "Report a bug to slack",
        "arguments": [
            {
                "name": "message",
                "type": "str",
                "description": "Description of the bug",
                "is_required": true
            }
        ],
        "returns": "(bool) true if successful",
        "examples": [
            {
                "title": "performing report_bug operation",
                "curl": "curl -d'{\"method\": \"report_bug\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  report_bug --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"report_bug\"}).json()",
                "output": "(bool) true if successful"
            }
        ]
    },
    {
        "name": "resolve",
        "description": "Resolve given LBRY URIs",
        "arguments": [
            {
                "name": "force",
                "type": "bool",
                "description": "force refresh and ignore cache",
                "is_required": false
            },
            {
                "name": "uri",
                "type": "str",
                "description": "uri to resolve",
                "is_required": true
            },
            {
                "name": "uris",
                "type": "list",
                "description": "uris to resolve",
                "is_required": false
            }
        ],
        "returns": "Dictionary of results, keyed by uri\n    '<uri>': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }",
        "examples": [
            {
                "title": "performing resolve operation",
                "curl": "curl -d'{\"method\": \"resolve\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  resolve --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"resolve\"}).json()",
                "output": "Dictionary of results, keyed by uri\n    '<uri>': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the certificate claim,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'permanent_url': (str) permanent url of the claim,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }"
            }
        ]
    },
    {
        "name": "resolve_name",
        "description": "Resolve stream info from a LBRY name",
        "arguments": [
            {
                "name": "name",
                "type": "str",
                "description": "the name to resolve",
                "is_required": true
            },
            {
                "name": "force",
                "type": "bool",
                "description": "force refresh and do not check cache",
                "is_required": false
            }
        ],
        "returns": "(dict) Metadata dictionary from name claim, None if the name is not\n            resolvable",
        "examples": [
            {
                "title": "performing resolve_name operation",
                "curl": "curl -d'{\"method\": \"resolve_name\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  resolve_name --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"resolve_name\"}).json()",
                "output": "(dict) Metadata dictionary from name claim, None if the name is not\n            resolvable"
            }
        ]
    },
    {
        "name": "routing_table_get",
        "description": "Get DHT routing information",
        "arguments": [],
        "returns": "(dict) dictionary containing routing and contact information\n    {\n        \"buckets\": {\n            <bucket index>: [\n                {\n                    \"address\": (str) peer address,\n                    \"port\": (int) peer udp port\n                    \"node_id\": (str) peer node id,\n                    \"blobs\": (list) blob hashes announced by peer\n                }\n            ]\n        },\n        \"contacts\": (list) contact node ids,\n        \"blob_hashes\": (list) all of the blob hashes stored by peers in the list of buckets,\n        \"node_id\": (str) the local dht node id\n    }",
        "examples": [
            {
                "title": "performing routing_table_get operation",
                "curl": "curl -d'{\"method\": \"routing_table_get\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  routing_table_get --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"routing_table_get\"}).json()",
                "output": "(dict) dictionary containing routing and contact information\n    {\n        \"buckets\": {\n            <bucket index>: [\n                {\n                    \"address\": (str) peer address,\n                    \"port\": (int) peer udp port\n                    \"node_id\": (str) peer node id,\n                    \"blobs\": (list) blob hashes announced by peer\n                }\n            ]\n        },\n        \"contacts\": (list) contact node ids,\n        \"blob_hashes\": (list) all of the blob hashes stored by peers in the list of buckets,\n        \"node_id\": (str) the local dht node id\n    }"
            }
        ]
    },
    {
        "name": "settings_get",
        "description": "Get daemon settings",
        "arguments": [],
        "returns": "(dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings",
        "examples": [
            {
                "title": "performing settings_get operation",
                "curl": "curl -d'{\"method\": \"settings_get\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  settings_get --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"settings_get\"}).json()",
                "output": "(dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings"
            }
        ]
    },
    {
        "name": "settings_set",
        "description": "Set daemon settings",
        "arguments": [
            {
                "name": "download_directory",
                "type": "str",
                "description": "path of download directory",
                "is_required": false
            },
            {
                "name": "data_rate",
                "type": "float",
                "description": "0.0001",
                "is_required": false
            },
            {
                "name": "download_timeout",
                "type": "int",
                "description": "180",
                "is_required": false
            },
            {
                "name": "peer_port",
                "type": "int",
                "description": "3333",
                "is_required": false
            },
            {
                "name": "max_key_fee",
                "type": "dict",
                "description": "maximum key fee for downloads, in the format: { 'currency': <currency_symbol>, 'amount': <amount> }. In the CLI, it must be an escaped JSON string Supported currency symbols: LBC, USD, BTC",
                "is_required": false
            },
            {
                "name": "disable_max_key_fee",
                "type": "bool",
                "description": "False",
                "is_required": false
            },
            {
                "name": "use_upnp",
                "type": "bool",
                "description": "True",
                "is_required": false
            },
            {
                "name": "run_reflector_server",
                "type": "bool",
                "description": "False",
                "is_required": false
            },
            {
                "name": "cache_time",
                "type": "int",
                "description": "150",
                "is_required": false
            },
            {
                "name": "reflect_uploads",
                "type": "bool",
                "description": "True",
                "is_required": false
            },
            {
                "name": "share_usage_data",
                "type": "bool",
                "description": "True",
                "is_required": false
            },
            {
                "name": "peer_search_timeout",
                "type": "int",
                "description": "3",
                "is_required": false
            },
            {
                "name": "sd_download_timeout",
                "type": "int",
                "description": "3",
                "is_required": false
            },
            {
                "name": "auto_renew_claim_height_delta",
                "type": "int",
                "description": "0 claims set to expire within this many blocks will be automatically renewed after startup (if set to 0, renews will not be made automatically)",
                "is_required": false
            }
        ],
        "returns": "(dict) Updated dictionary of daemon settings",
        "examples": [
            {
                "title": "performing settings_set operation",
                "curl": "curl -d'{\"method\": \"settings_set\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  settings_set --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"settings_set\"}).json()",
                "output": "(dict) Updated dictionary of daemon settings"
            }
        ]
    },
    {
        "name": "status",
        "description": "Get daemon status",
        "arguments": [],
        "returns": "(dict) lbrynet-daemon status\n    {\n        'installation_id': (str) installation id - base58,\n        'is_running': (bool),\n        'is_first_run': bool,\n        'skipped_components': (list) [names of skipped components (str)],\n        'startup_status': { Does not include components which have been skipped\n            'database': (bool),\n            'wallet': (bool),\n            'session': (bool),\n            'dht': (bool),\n            'hash_announcer': (bool),\n            'stream_identifier': (bool),\n            'file_manager': (bool),\n            'blob_manager': (bool),\n            'blockchain_headers': (bool),\n            'peer_protocol_server': (bool),\n            'reflector': (bool),\n            'upnp': (bool),\n            'exchange_rate_manager': (bool),\n        },\n        'connection_status': {\n            'code': (str) connection status code,\n            'message': (str) connection status message\n        },\n        'blockchain_headers': {\n            'downloading_headers': (bool),\n            'download_progress': (float) 0-100.0\n        },\n        'wallet': {\n            'blocks': (int) local blockchain height,\n            'blocks_behind': (int) remote_height - local_height,\n            'best_blockhash': (str) block hash of most recent block,\n            'is_encrypted': (bool),\n            'is_locked': (bool),\n        },\n        'dht': {\n            'node_id': (str) lbry dht node id - hex encoded,\n            'peers_in_routing_table': (int) the number of peers in the routing table,\n        },\n        'blob_manager': {\n            'finished_blobs': (int) number of finished blobs in the blob manager,\n        },\n        'hash_announcer': {\n            'announce_queue_size': (int) number of blobs currently queued to be announced\n        },\n        'file_manager': {\n            'managed_files': (int) count of files in the file manager,\n        },\n        'upnp': {\n            'aioupnp_version': (str),\n            'redirects': {\n                <TCP | UDP>: (int) external_port,\n            },\n            'gateway': (str) manufacturer and model,\n            'dht_redirect_set': (bool),\n            'peer_redirect_set': (bool),\n            'external_ip': (str) external ip address,\n        }\n    }",
        "examples": [
            {
                "title": "performing status operation",
                "curl": "curl -d'{\"method\": \"status\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  status --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"status\"}).json()",
                "output": "(dict) lbrynet-daemon status\n    {\n        'installation_id': (str) installation id - base58,\n        'is_running': (bool),\n        'is_first_run': bool,\n        'skipped_components': (list) [names of skipped components (str)],\n        'startup_status': { Does not include components which have been skipped\n            'database': (bool),\n            'wallet': (bool),\n            'session': (bool),\n            'dht': (bool),\n            'hash_announcer': (bool),\n            'stream_identifier': (bool),\n            'file_manager': (bool),\n            'blob_manager': (bool),\n            'blockchain_headers': (bool),\n            'peer_protocol_server': (bool),\n            'reflector': (bool),\n            'upnp': (bool),\n            'exchange_rate_manager': (bool),\n        },\n        'connection_status': {\n            'code': (str) connection status code,\n            'message': (str) connection status message\n        },\n        'blockchain_headers': {\n            'downloading_headers': (bool),\n            'download_progress': (float) 0-100.0\n        },\n        'wallet': {\n            'blocks': (int) local blockchain height,\n            'blocks_behind': (int) remote_height - local_height,\n            'best_blockhash': (str) block hash of most recent block,\n            'is_encrypted': (bool),\n            'is_locked': (bool),\n        },\n        'dht': {\n            'node_id': (str) lbry dht node id - hex encoded,\n            'peers_in_routing_table': (int) the number of peers in the routing table,\n        },\n        'blob_manager': {\n            'finished_blobs': (int) number of finished blobs in the blob manager,\n        },\n        'hash_announcer': {\n            'announce_queue_size': (int) number of blobs currently queued to be announced\n        },\n        'file_manager': {\n            'managed_files': (int) count of files in the file manager,\n        },\n        'upnp': {\n            'aioupnp_version': (str),\n            'redirects': {\n                <TCP | UDP>: (int) external_port,\n            },\n            'gateway': (str) manufacturer and model,\n            'dht_redirect_set': (bool),\n            'peer_redirect_set': (bool),\n            'external_ip': (str) external ip address,\n        }\n    }"
            }
        ]
    },
    {
        "name": "stop",
        "description": "Stop lbrynet",
        "arguments": [],
        "returns": "(string) Shutdown message",
        "examples": [
            {
                "title": "performing stop operation",
                "curl": "curl -d'{\"method\": \"stop\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  stop --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"stop\"}).json()",
                "output": "(string) Shutdown message"
            }
        ]
    },
    {
        "name": "stream_availability",
        "description": "Get stream availability for lbry uri",
        "arguments": [
            {
                "name": "uri",
                "type": "str",
                "description": "check availability for this uri",
                "is_required": true
            },
            {
                "name": "search_timeout",
                "type": "int",
                "description": "how long to search for peers for the blob in the dht",
                "is_required": false
            },
            {
                "name": "blob_timeout",
                "type": "int",
                "description": "how long to try downloading from a peer",
                "is_required": false
            }
        ],
        "returns": "(dict) {\n        'is_available': <bool>,\n        'did_decode': <bool>,\n        'did_resolve': <bool>,\n        'is_stream': <bool>,\n        'num_blobs_in_stream': <int>,\n        'sd_hash': <str>,\n        'sd_blob_availability': <dict> see `blob_availability`,\n        'head_blob_hash': <str>,\n        'head_blob_availability': <dict> see `blob_availability`,\n        'use_upnp': <bool>,\n        'upnp_redirect_is_set': <bool>,\n        'error': <None> | <str> error message\n    }",
        "examples": [
            {
                "title": "performing stream_availability operation",
                "curl": "curl -d'{\"method\": \"stream_availability\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  stream_availability --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"stream_availability\"}).json()",
                "output": "(dict) {\n        'is_available': <bool>,\n        'did_decode': <bool>,\n        'did_resolve': <bool>,\n        'is_stream': <bool>,\n        'num_blobs_in_stream': <int>,\n        'sd_hash': <str>,\n        'sd_blob_availability': <dict> see `blob_availability`,\n        'head_blob_hash': <str>,\n        'head_blob_availability': <dict> see `blob_availability`,\n        'use_upnp': <bool>,\n        'upnp_redirect_is_set': <bool>,\n        'error': <None> | <str> error message\n    }"
            }
        ]
    },
    {
        "name": "stream_cost_estimate",
        "description": "Get estimated cost for a lbry stream",
        "arguments": [
            {
                "name": "uri",
                "type": "str",
                "description": "uri to use",
                "is_required": true
            },
            {
                "name": "size",
                "type": "float",
                "description": "stream size in bytes. if provided an sd blob won't be downloaded.",
                "is_required": false
            }
        ],
        "returns": "(float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable",
        "examples": [
            {
                "title": "performing stream_cost_estimate operation",
                "curl": "curl -d'{\"method\": \"stream_cost_estimate\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  stream_cost_estimate --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"stream_cost_estimate\"}).json()",
                "output": "(float) Estimated cost in lbry credits, returns None if uri is not\n        resolvable"
            }
        ]
    },
    {
        "name": "transaction_list",
        "description": "List transactions belonging to wallet",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to query",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page to return during paginating",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of items on page during pagination",
                "is_required": false
            }
        ],
        "returns": "(list) List of transactions\n\n    {\n        \"claim_info\": (list) claim info if in txn [{\n                                                \"address\": (str) address of claim,\n                                                \"balance_delta\": (float) bid amount,\n                                                \"amount\": (float) claim amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"abandon_info\": (list) abandon info if in txn [{\n                                                \"address\": (str) address of abandoned claim,\n                                                \"balance_delta\": (float) returned amount,\n                                                \"amount\": (float) claim amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"confirmations\": (int) number of confirmations for the txn,\n        \"date\": (str) date and time of txn,\n        \"fee\": (float) txn fee,\n        \"support_info\": (list) support info if in txn [{\n                                                \"address\": (str) address of support,\n                                                \"balance_delta\": (float) support amount,\n                                                \"amount\": (float) support amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"is_tip\": (bool),\n                                                \"nout\": (int) nout\n                                                }],\n        \"timestamp\": (int) timestamp,\n        \"txid\": (str) txn id,\n        \"update_info\": (list) update info if in txn [{\n                                                \"address\": (str) address of claim,\n                                                \"balance_delta\": (float) credited/debited\n                                                \"amount\": (float) absolute amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"value\": (float) value of txn\n    }",
        "examples": [
            {
                "title": "performing transaction_list operation",
                "curl": "curl -d'{\"method\": \"transaction_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  transaction_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"transaction_list\"}).json()",
                "output": "(list) List of transactions\n\n    {\n        \"claim_info\": (list) claim info if in txn [{\n                                                \"address\": (str) address of claim,\n                                                \"balance_delta\": (float) bid amount,\n                                                \"amount\": (float) claim amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"abandon_info\": (list) abandon info if in txn [{\n                                                \"address\": (str) address of abandoned claim,\n                                                \"balance_delta\": (float) returned amount,\n                                                \"amount\": (float) claim amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"confirmations\": (int) number of confirmations for the txn,\n        \"date\": (str) date and time of txn,\n        \"fee\": (float) txn fee,\n        \"support_info\": (list) support info if in txn [{\n                                                \"address\": (str) address of support,\n                                                \"balance_delta\": (float) support amount,\n                                                \"amount\": (float) support amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"is_tip\": (bool),\n                                                \"nout\": (int) nout\n                                                }],\n        \"timestamp\": (int) timestamp,\n        \"txid\": (str) txn id,\n        \"update_info\": (list) update info if in txn [{\n                                                \"address\": (str) address of claim,\n                                                \"balance_delta\": (float) credited/debited\n                                                \"amount\": (float) absolute amount,\n                                                \"claim_id\": (str) claim id,\n                                                \"claim_name\": (str) claim name,\n                                                \"nout\": (int) nout\n                                                }],\n        \"value\": (float) value of txn\n    }"
            }
        ]
    },
    {
        "name": "transaction_show",
        "description": "Get a decoded transaction from a txid",
        "arguments": [
            {
                "name": "txid",
                "type": "str",
                "description": "txid of the transaction",
                "is_required": true
            }
        ],
        "returns": "(dict) JSON formatted transaction",
        "examples": [
            {
                "title": "performing transaction_show operation",
                "curl": "curl -d'{\"method\": \"transaction_show\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  transaction_show --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"transaction_show\"}).json()",
                "output": "(dict) JSON formatted transaction"
            }
        ]
    },
    {
        "name": "utxo_list",
        "description": "List unspent transaction outputs",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to query",
                "is_required": false
            },
            {
                "name": "page",
                "type": "int",
                "description": "page to return during paginating",
                "is_required": false
            },
            {
                "name": "page_size",
                "type": "int",
                "description": "number of items on page during pagination",
                "is_required": false
            }
        ],
        "returns": "(list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n            \"address\": (str) the output address\n            \"amount\": (float) unspent amount\n            \"height\": (int) block height\n            \"is_claim\": (bool) is the tx a claim\n            \"is_coinbase\": (bool) is the tx a coinbase tx\n            \"is_support\": (bool) is the tx a support\n            \"is_update\": (bool) is the tx an update\n            \"nout\": (int) nout of the output\n            \"txid\": (str) txid of the output\n        },\n        ...\n    ]",
        "examples": [
            {
                "title": "performing utxo_list operation",
                "curl": "curl -d'{\"method\": \"utxo_list\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  utxo_list --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"utxo_list\"}).json()",
                "output": "(list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n            \"address\": (str) the output address\n            \"amount\": (float) unspent amount\n            \"height\": (int) block height\n            \"is_claim\": (bool) is the tx a claim\n            \"is_coinbase\": (bool) is the tx a coinbase tx\n            \"is_support\": (bool) is the tx a support\n            \"is_update\": (bool) is the tx an update\n            \"nout\": (int) nout of the output\n            \"txid\": (str) txid of the output\n        },\n        ...\n    ]"
            }
        ]
    },
    {
        "name": "utxo_release",
        "description": "When spending a UTXO it is locally locked to prevent double spends;\noccasionally this can result in a UTXO being locked which ultimately\ndid not get spent (failed to broadcast, spend transaction was not\naccepted by blockchain node, etc). This command releases the lock\non all UTXOs in your account.",
        "arguments": [
            {
                "name": "account_id",
                "type": "str",
                "description": "id of the account to query",
                "is_required": false
            }
        ],
        "returns": "None",
        "examples": [
            {
                "title": "performing utxo_release operation",
                "curl": "curl -d'{\"method\": \"utxo_release\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  utxo_release --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"utxo_release\"}).json()",
                "output": "None"
            }
        ]
    },
    {
        "name": "version",
        "description": "Get lbry version information",
        "arguments": [],
        "returns": "(dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \"dev\", \"rc\", \"release\"),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }",
        "examples": [
            {
                "title": "performing version operation",
                "curl": "curl -d'{\"method\": \"version\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  version --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"version\"}).json()",
                "output": "(dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \"dev\", \"rc\", \"release\"),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }"
            }
        ]
    },
    {
        "name": "wallet_send",
        "description": "Send credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.",
        "arguments": [
            {
                "name": "amount",
                "type": "decimal",
                "description": "amount of credit to send",
                "is_required": true
            },
            {
                "name": "address",
                "type": "str",
                "description": "address to send credits to",
                "is_required": true
            },
            {
                "name": "claim_id",
                "type": "str",
                "description": "claim_id of the claim to send to tip to",
                "is_required": true
            },
            {
                "name": "account_id",
                "type": "str",
                "description": "account to fund the transaction",
                "is_required": false
            }
        ],
        "returns": "If sending to an address:\n    (dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }",
        "examples": [
            {
                "title": "performing wallet_send operation",
                "curl": "curl -d'{\"method\": \"wallet_send\"}' http://localhost:5279/",
                "lbrynet": "lbrynet  wallet_send --some-arg=foo",
                "python": "requests.post(\"http://localhost:5279\", json={\"method\": \"wallet_send\"}).json()",
                "output": "If sending to an address:\n    (dict) Dictionary containing the transaction information\n    {\n        \"hex\": (str) raw transaction,\n        \"inputs\": (list) inputs(dict) used for the transaction,\n        \"outputs\": (list) outputs(dict) for the transaction,\n        \"total_fee\": (int) fee in dewies,\n        \"total_input\": (int) total of inputs in dewies,\n        \"total_output\": (int) total of outputs in dewies(input - fees),\n        \"txid\": (str) txid of the transaction,\n    }\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }"
            }
        ]
    }
]